<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jellyyoung&#39;s Blog</title>
  <subtitle>一只不会编程还想做数据科学的coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yaodong.ml/"/>
  <updated>2016-11-03T15:01:51.156Z</updated>
  <id>http://yaodong.ml/</id>
  
  <author>
    <name>摇摇果冻</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kaggle竞赛学习资源汇总</title>
    <link href="http://yaodong.ml/Kaggle%E7%AB%9E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB.html"/>
    <id>http://yaodong.ml/Kaggle竞赛学习资源汇总.html</id>
    <published>2016-11-03T08:21:46.000Z</published>
    <updated>2016-11-03T15:01:51.156Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Kaggle竞赛相比于国内的数据科学、机器学习类比赛，入门教程更丰富，foreigners对解题方案的讲解更详细，因此Kaggle竞赛对于数据科学爱好者是一个不错的学习资源。本博文整理了Kaggle竞赛的相关学习资源，欢迎交流。<br><a id="more"></a></p>
<h3 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h3><ol>
<li><a href="https://www.kaggle.com/competitions" target="_blank" rel="external">Kaggle竞赛主页</a></li>
<li><a href="https://www.kaggle.com/kernels" target="_blank" rel="external">Kaggle Kernels</a></li>
<li><a href="https://www.kaggle.com/forums" target="_blank" rel="external">Kaggle Forums</a></li>
<li><a href="https://www.kaggle.com/wiki/PastSolutions" target="_blank" rel="external">Kaggle Past Solutions</a></li>
</ol>
<h3 id="Kaggle竞赛相关的博客"><a href="#Kaggle竞赛相关的博客" class="headerlink" title="Kaggle竞赛相关的博客"></a>Kaggle竞赛相关的博客</h3><ol>
<li>Kaggle实战的科普博客：<a href="http://nanjunxiao.github.io/2015/07/30/Kaggle%E5%AE%9E%E6%88%98%E4%B8%80/" target="_blank" rel="external">Kaggle实战（一）</a>，<a href="http://nanjunxiao.github.io/2015/07/31/Kaggle%E5%AE%9E%E6%88%98%E4%BA%8C/" target="_blank" rel="external">Kaggle实战（二）</a></li>
<li><a href="http://www.cnblogs.com/kobedeshow/p/4118361.html" target="_blank" rel="external">数据挖掘比赛——Kaggle实战</a></li>
<li>清华大学范淼博士的Kaggle实战：<a href="https://mlnote.wordpress.com/2015/12/16/python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5%E4%B8%8Ekaggle%E5%AE%9E%E6%88%98-machine-learning-for-kaggle-competition-in-python/" target="_blank" rel="external">Python机器学习实践与Kaggle实战</a></li>
<li>强力推荐！关于Titanic赛题的solution。<a href="https://github.com/cindycindyhi/kaggle-Titanic" target="_blank" rel="external">作者</a>从数据预处理、特征提取、特征生成、模型评估各个方面都进行了详细的讲解，是机器学习实践的比较好的学习资源。传送门：<strong>solution</strong> <a href="http://www.cnblogs.com/north-north/p/4353365.html" target="_blank" rel="external">step 1</a>，<a href="http://www.cnblogs.com/north-north/p/4354775.html" target="_blank" rel="external">step 2</a> ，<a href="http://www.cnblogs.com/north-north/p/4358084.html" target="_blank" rel="external">step 3</a>，<a href="http://www.cnblogs.com/north-north/p/4360121.html" target="_blank" rel="external">step 4</a></li>
<li><a href="http://www.jianshu.com/p/32def2294ae6" target="_blank" rel="external">用python参加Kaggle的些许经验总结</a></li>
</ol>
<h3 id="Kaggle-Solution的源码"><a href="#Kaggle-Solution的源码" class="headerlink" title="Kaggle Solution的源码"></a>Kaggle Solution的源码</h3><ol>
<li><a href="http://suanfazu.com/t/kaggle/230" target="_blank" rel="external">Kaggle 机器学习竞赛冠军及优胜者的源代码汇总 - 算法组</a></li>
<li><a href="http://www.chioka.in/kaggle-competition-solutions/" target="_blank" rel="external">Kaggle Competition Past Solutions</a></li>
<li><a href="http://dsguide.biz/competitions/" target="_blank" rel="external">Solutions from past competitions</a></li>
</ol>
<h4 id="Bike-Sharing-Demand"><a href="#Bike-Sharing-Demand" class="headerlink" title="Bike Sharing Demand"></a>Bike Sharing Demand</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/bike-sharing-demand" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="http://nbviewer.jupyter.org/gist/whbzju/ff06fce9fd738dcf8096" target="_blank" rel="external">referenced solution</a></p>
<h4 id="Titanic-Machine-Learning-from-Disaster"><a href="#Titanic-Machine-Learning-from-Disaster" class="headerlink" title="Titanic: Machine Learning from Disaster"></a>Titanic: Machine Learning from Disaster</h4><ul>
<li>推荐这个solution，<a href="https://github.com/cindycindyhi/kaggle-Titanic" target="_blank" rel="external">cindycindyhi</a></li>
<li><a href="https://github.com/agconti/kaggle-titanic" target="_blank" rel="external">agconti - github</a><h4 id="Galaxy-Zoo-The-Galaxy-Challenge"><a href="#Galaxy-Zoo-The-Galaxy-Challenge" class="headerlink" title="Galaxy Zoo The Galaxy Challenge"></a>Galaxy Zoo The Galaxy Challenge</h4>&emsp;&emsp;<a href="https://github.com/benanne/kaggle-galaxies" target="_blank" rel="external">benanne - github
</a><h4 id="How-Much-Did-It-Rain"><a href="#How-Much-Did-It-Rain" class="headerlink" title="How Much Did It Rain?"></a>How Much Did It Rain?</h4>&emsp;&emsp;<a href="https://github.com/simaaron/kaggle-Rain" target="_blank" rel="external">simaaron - github
</a><h4 id="National-Data-Science-Bowl"><a href="#National-Data-Science-Bowl" class="headerlink" title="National Data Science Bowl"></a>National Data Science Bowl</h4>&emsp;&emsp;<a href="https://www.kaggle.com/c/datasciencebowl" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/benanne/kaggle-ndsb" target="_blank" rel="external">Win solution of benanne</a><h4 id="Crowdflower-Search-Results-Relevance"><a href="#Crowdflower-Search-Results-Relevance" class="headerlink" title="Crowdflower Search Results Relevance"></a>Crowdflower Search Results Relevance</h4>&emsp;&emsp;<a href="https://www.kaggle.com/c/crowdflower-search-relevance" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/ChenglongChen/Kaggle_CrowdFlower" target="_blank" rel="external">win solution of ChenglongChen on github</a><h4 id="Amazon-com-Employee-Access-Challenge"><a href="#Amazon-com-Employee-Access-Challenge" class="headerlink" title="Amazon.com - Employee Access Challenge"></a>Amazon.com - Employee Access Challenge</h4>&emsp;&emsp;<a href="https://www.kaggle.com/c/amazon-employee-access-challenge" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://www.kaggle.com/c/amazon-employee-access-challenge/forums/t/5283/winning-solution-code-and-methodology" target="_blank" rel="external">Winning solution code and methodology</a><br>&emsp;&emsp;<a href="https://www.kaggle.com/c/amazon-employee-access-challenge/forums/t/5283/winning-solution-code-and-methodology" target="_blank" rel="external">Winning solution code and methodology</a></li>
</ul>
<h4 id="BCI-Challenge-NER-2015"><a href="#BCI-Challenge-NER-2015" class="headerlink" title="BCI Challenge @ NER 2015"></a>BCI Challenge @ NER 2015</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/inria-bci-challenge" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/alexandrebarachant/bci-challenge-ner-2015" target="_blank" rel="external">Winning solution of Alexandre Barachant</a></p>
<h4 id="Microsoft-Malware-Classification-Challenge-BIG-2015"><a href="#Microsoft-Malware-Classification-Challenge-BIG-2015" class="headerlink" title="Microsoft Malware Classification Challenge (BIG 2015)"></a>Microsoft Malware Classification Challenge (BIG 2015)</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/malware-classification" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/daxiongshu/kaggle_Microsoft_Malware" target="_blank" rel="external">Winning solution of daxiongshu</a></p>
<h4 id="Telstra-Network-Disruptions"><a href="#Telstra-Network-Disruptions" class="headerlink" title="Telstra Network Disruptions"></a>Telstra Network Disruptions</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/telstra-recruiting-network" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/aarshayj/Kaggle/tree/master/Telstra_Network_Disruptions" target="_blank" rel="external">Winning solution of aarshayj</a></p>
<h4 id="Loan-Default-Prediction-Imperial-College-London"><a href="#Loan-Default-Prediction-Imperial-College-London" class="headerlink" title="Loan Default Prediction - Imperial College London"></a>Loan Default Prediction - Imperial College London</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/loan-default-prediction" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/freedomljc/Loan_Default_Prediction" target="_blank" rel="external">Winning solution of freedomljc</a></p>
<h4 id="Detecting-Insults-in-Social-Commentary"><a href="#Detecting-Insults-in-Social-Commentary" class="headerlink" title="Detecting Insults in Social Commentary"></a>Detecting Insults in Social Commentary</h4><p>&emsp;&emsp;<a href="https://www.kaggle.com/c/detecting-insults-in-social-commentary" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/amueller/kaggle_insults/" target="_blank" rel="external">Winning solution of amueller</a></p>
<h4 id="阿里移动推荐算法"><a href="#阿里移动推荐算法" class="headerlink" title="阿里移动推荐算法"></a>阿里移动推荐算法</h4><p>&emsp;&emsp;<a href="https://tianchi.shuju.aliyun.com/competition/introduction.htm?spm=5176.100066.333.2.umhl4N&amp;raceId=1" target="_blank" rel="external">赛题链接</a><br>&emsp;&emsp;<a href="https://github.com/wepe/AliTianChi/tree/master/%E9%98%BF%E9%87%8C%E7%A7%BB%E5%8A%A8%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/Season1" target="_blank" rel="external">solution of wepe</a><br>&emsp;&emsp;<a href="https://github.com/hbiner/2015RecommendationCompetition" target="_blank" rel="external">solution of  hbiner</a><br>&emsp;&emsp;<a href="http://blog.csdn.net/sin_geek/article/details/45787309" target="_blank" rel="external">CSDN博客：关于2015阿里移动推荐算法大赛的总结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Kaggle竞赛相比于国内的数据科学、机器学习类比赛，入门教程更丰富，foreigners对解题方案的讲解更详细，因此Kaggle竞赛对于数据科学爱好者是一个不错的学习资源。本博文整理了Kaggle竞赛的相关学习资源，欢迎交流。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python爬虫学习资源汇总</title>
    <link href="http://yaodong.ml/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB.html"/>
    <id>http://yaodong.ml/python爬虫学习资源汇总.html</id>
    <published>2016-11-03T07:37:38.000Z</published>
    <updated>2016-11-03T08:18:02.035Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近想参加数据类的比赛，暂时没有时间学爬虫。本博文整理了爬虫的相关学习资源，以后有时间了再学爬虫。欢迎交流。<br><a id="more"></a><br>&emsp;&emsp;<strong>爬虫</strong>就是自动抓取目标网站上的全部或部分资源。目前用于爬虫的编程语言也较多，本人擅长python和java，因此本博文涉及的学习资源大多是<strong>java</strong>和<strong>python</strong>相关的。本文会不定时更新。</p>
<h3 id="知乎上关于爬虫的问题"><a href="#知乎上关于爬虫的问题" class="headerlink" title="知乎上关于爬虫的问题"></a>知乎上关于爬虫的问题</h3><ol>
<li><a href="https://www.zhihu.com/question/20899988" target="_blank" rel="external">如何入门 Python 爬虫 - 知乎？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21479334?refer=passer" target="_blank" rel="external">如何学习Python爬虫(入门篇)？</a>，比较推荐这个，系统地整理了爬虫入门学习资源</li>
<li><a href="https://www.zhihu.com/question/47883186" target="_blank" rel="external">零基础如何学爬虫技术？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/27621722" target="_blank" rel="external">利用爬虫技术能做到哪些很酷很有趣很有用的事情？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/35461941" target="_blank" rel="external">Python 爬虫进阶？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/topic/19794679/hot" target="_blank" rel="external">网页爬虫 - 知乎专栏</a></li>
</ol>
<h3 id="爬虫相关的学习教程、博客"><a href="#爬虫相关的学习教程、博客" class="headerlink" title="爬虫相关的学习教程、博客"></a>爬虫相关的学习教程、博客</h3><ol>
<li><a href="http://www.lining0806.com/category/spider/" target="_blank" rel="external">宁哥的小站：网络爬虫</a></li>
<li><a href="http://cuiqingcai.com/1052.html" target="_blank" rel="external">python爬虫学习系列教程|静觅</a></li>
<li><a href="http://cuiqingcai.com/" target="_blank" rel="external">静觅博客</a></li>
<li><a href="http://blog.csdn.net/column/details/why-bug.html" target="_blank" rel="external">CSDN专栏：Python爬虫入门教程</a></li>
<li><a href="https://segmentfault.com/t/%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB/blogs?page=1" target="_blank" rel="external">Segmentfault专栏：网页爬虫</a></li>
<li><a href="http://chenqx.github.io/2014/11/09/Scrapy-Tutorial-for-BBSSpider/" target="_blank" rel="external">Scrapy爬虫抓取网站数据</a></li>
<li><a href="https://github.com/search?q=crawler&amp;ref=cmdform" target="_blank" rel="external">Github上开源的爬虫框架</a><h3 id="python爬虫实战"><a href="#python爬虫实战" class="headerlink" title="python爬虫实战"></a>python爬虫实战</h3></li>
<li><a href="http://www.cnblogs.com/wanghzh/p/5824181.html" target="_blank" rel="external">战神王恒：用python爬虫框架Scrapy爬取心目中的女神</a><h3 id="爬虫书籍推荐"><a href="#爬虫书籍推荐" class="headerlink" title="爬虫书籍推荐"></a>爬虫书籍推荐</h3></li>
<li>《用python写网络爬虫》</li>
<li>《Python网络数据采集》</li>
<li>《干净的数据——数据清洗入门与实践》</li>
<li>《自己动手写网络爬虫（修订版）》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近想参加数据类的比赛，暂时没有时间学爬虫。本博文整理了爬虫的相关学习资源，以后有时间了再学爬虫。欢迎交流。&lt;br&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://yaodong.ml/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="python" scheme="http://yaodong.ml/tags/python/"/>
    
      <category term="爬虫" scheme="http://yaodong.ml/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="http://yaodong.ml/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yaodong.ml/MySQL学习笔记.html</id>
    <published>2016-11-03T03:37:21.000Z</published>
    <updated>2016-11-03T06:06:07.224Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本博文记录MySQL的相关学习笔记，欢迎指正。<br><a id="more"></a></p>
<h3 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h3><ol>
<li>常用关系数据库：</li>
</ol>
<ul>
<li><strong>Oracle</strong></li>
<li><strong>MySQL</strong></li>
<li><strong>DB2</strong></li>
<li><strong>SQL Server</strong></li>
</ul>
<ol>
<li><strong>SQL</strong>：<strong>Structrured Query Language</strong>，结构化查询语言，是一种定义、操作、管理<strong>关系数据库</strong>的语法。</li>
<li><strong>编程大小写问题</strong>：<strong>MySQL</strong>在<strong>window</strong>系统下不区分大小写，在其他系统严格区分大小写。</li>
<li>可以使用<strong>反引号</strong>``把关键字包含起来，当做普通字符串使用。</li>
<li><strong>Java</strong>与<strong>SQL</strong>语言的对应关系：</li>
</ol>
<ul>
<li><strong>Java</strong>类和表结构对应的；</li>
<li><strong>Java</strong>对象和表中的一条记录是对应的</li>
</ul>
<h3 id="MySQL语言组成"><a href="#MySQL语言组成" class="headerlink" title="MySQL语言组成"></a>MySQL语言组成</h3><ol>
<li><strong>数据定义语言</strong>(<strong>DDL</strong>，Data Definition Language)</li>
</ol>
<ul>
<li>描述数据库中要存储的现实世界实体的语言；</li>
<li>用于创建数据库或数据库的各种对象：<strong>表</strong>、<strong>视图</strong>、<strong>索引</strong>、<strong>同义词</strong>、<strong>聚簇</strong>等；</li>
<li><strong>常用关键字</strong>：<code>CREATE</code>，<code>ALTER</code> ，<code>DROP</code> ，<code>TRUNCATE</code></li>
<li>使用对象：<strong>DB Designer/Developer</strong></li>
</ul>
<ol>
<li><strong>数据查询语言</strong>(<strong>DQL</strong>: Data Query Language)</li>
</ol>
<ul>
<li>用于从表中查询并获取数据。</li>
<li>DQL基本结构是由<strong>SELECT</strong>子句，<strong>FROM</strong>子句，<strong>WHERE</strong>子句组成的查询块：<ol>
<li><code>SELECT</code> &lt;字段名表&gt;</li>
<li><code>FROM</code> &lt;表或视图名&gt;</li>
<li><code>WHERE</code> &lt;查询条件&gt;</li>
<li><code>ORDER BY</code>&lt;排序条件&gt;</li>
<li><code>AS</code>&lt;别名设置&gt;</li>
<li><code>BETWEEN AND</code></li>
<li><code>IN</code></li>
<li><code>DESC</code>/<code>ASC</code></li>
</ol>
</li>
<li>逻辑运算符：<code>and</code>/<code>or</code>/<code>not</code></li>
<li><code>LIKE</code>多用于<strong>模糊查询</strong>：<code>%</code>代表零个或多个字符； <code>_</code>代表一个字符</li>
</ul>
<ol>
<li><strong>数据操作语言</strong>(<strong>DML</strong>：Data Manipulation Language)</li>
</ol>
<ul>
<li>也称为动作查询语言；</li>
<li>用于对数据库表完成插入(<strong>INSERT</strong>)、删除(<strong>DELETE</strong>)、修改(<strong>UPDATE</strong>)数据操作；</li>
<li>常用关键字：<code>SELECT</code> ，<code>UPDATE</code>，<code>DELETE</code></li>
<li>使用对象：<strong>DB User</strong></li>
<li><strong>特别注意</strong>：MySQL语法中，字符串或日期要包含在单引号中</li>
</ul>
<ol>
<li><strong>数据控制语言</strong>(<strong>DCL</strong>：Data Control Language)：</li>
</ol>
<ul>
<li>对数据库的访问进行控制，包括数据完整性控制、数据安全性控制、数据库的恢复；</li>
<li>常用语句：<code>GRANT</code>,<code>DENY</code>,<code>REVOKE</code></li>
<li>使用对象：<strong>DBA</strong></li>
</ul>
<ol>
<li><strong>事务处理语言</strong>(<strong>TPL</strong>：Transaction Processing Language)：</li>
<li><strong>指针控制语言</strong>(<strong>CCL</strong>)：</li>
</ol>
<h3 id="MySQL命令行操作"><a href="#MySQL命令行操作" class="headerlink" title="MySQL命令行操作"></a>MySQL命令行操作</h3><ol>
<li>查看<strong>MySQL</strong>安装版本：<ul>
<li>输入<code>mysql&gt; status;</code></li>
<li>终端下cmd输入：<code>mysql -V</code></li>
<li>调用<strong>MySQL</strong>函数：<code>mysql&gt; select version();</code></li>
</ul>
</li>
<li><strong>Window</strong>下验证<strong>MySQL</strong>是否安装成功，若成功则连接到<strong>MySQL</strong>服务器：<ul>
<li><code>mysql -u root -p</code></li>
</ul>
</li>
<li><p>配置数据库服务器<strong>MySQL</strong></p>
<ul>
<li>图形化配置<strong>MySQL</strong></li>
<li>手工配置<strong>MySQL</strong></li>
</ul>
</li>
<li><p><strong>DOS</strong>登录<strong>MySQL</strong>服务器：</p>
<ul>
<li><code>mysql 127.0.0.1 -u root -p</code></li>
</ul>
</li>
<li><p><font color="#FF0000"><strong>数据库对象</strong></font>是指 存储、管理和使用数据的不同结构形式，主要包含<strong>表</strong>、<strong>视图</strong>、<strong>存储过程</strong>、<strong>函数</strong>、<strong>触发器</strong>和<strong>事件</strong>等。</p>
</li>
</ol>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li>常用关键字：<code>CREATE</code>，<code>ALTER</code>，<code>DROP</code>，<code>TRUNCATE</code>，</li>
<li>显示所有的数据库：<code>SHOW DATABASES;</code></li>
<li>创建一个名称为mydb1的数据库：<code>CREATE DATABASE mydb1;</code></li>
<li>查看数据库的创建细节：<code>SHOW CREATE DATABASE mydb1;</code></li>
<li>创建一个使用gbk字符集的mydb2数据库：<br>  <code>CREATE DATABASE mydb2 CHARACTER SET gbk;</code></li>
<li>创建一个使用gbk字符集，并带校对规则的mydb3数据库：<br><code>CREATE DATABASE mydb3 CHARACTER SET gbk COLLATE gbk_chinese_ci;</code></li>
<li>删除数据库mydb3：<code>DROP DATABASE mydb3;</code></li>
<li>查看服务器中的数据库，并把mydb2的字符集修改为utf8：<br><code>ALTER DATABASE mydb2 CHARACTER SET utf8;</code><h3 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h3></li>
</ul>
<ol>
<li>整数类型：<ul>
<li>标准类型：<strong>INT</strong>，<strong>SMALLINT</strong></li>
<li>扩展类型：<strong>TINYIINT</strong>，<strong>MEDIUMINT</strong>，<strong>BIGINT</strong></li>
</ul>
</li>
<li>字符串类型</li>
</ol>
<ul>
<li><strong>CHAR</strong>系列字符串类型<ul>
<li><strong>CHAR(M)</strong>：字符串长度一般不变</li>
<li><strong>VARCHAR(M)</strong>：长度可变的字符串类型</li>
</ul>
</li>
<li><strong>TEXT</strong>系列字符串类型：<em>TEXT*</em>类型适用于存储大量字符串，如：存储大量的纯文本<ul>
<li><strong>TINYTEXT</strong></li>
<li><strong>TEXT</strong></li>
<li><strong>MEDIUMTEXT</strong></li>
<li><strong>LONGTEXT</strong> </li>
</ul>
</li>
<li><strong>BINARY</strong>系列字符串类型     <ul>
<li><strong>BINARY(M)</strong></li>
<li><strong>VARBINARY(M)</strong></li>
</ul>
</li>
<li>BLOB系列字符串类型<ul>
<li><strong>TINYBOLB</strong></li>
<li><strong>BLOB</strong></li>
<li><strong>MEDIUMBOLB</strong></li>
<li><strong>LONGBLOB</strong></li>
</ul>
</li>
</ul>
<ol>
<li>浮点型类型</li>
</ol>
<ul>
<li>浮点型类型<ul>
<li><strong>FLOAT</strong></li>
<li><strong>DOUBLE</strong></li>
</ul>
</li>
<li>定点数类型<ul>
<li><strong>DEC(M,D)</strong></li>
<li><strong>DECIMAL(M,D)</strong></li>
</ul>
</li>
<li>位类型<ul>
<li><strong>BIT(M)</strong></li>
</ul>
</li>
</ul>
<ol>
<li>日期和事件类型</li>
</ol>
<ul>
<li><strong>DATE</strong></li>
<li><strong>DATETIME</strong></li>
<li><strong>TIMESTAMP</strong></li>
<li><strong>TIME</strong></li>
<li><strong>YEAR</strong></li>
</ul>
<h3 id="表结构操作"><a href="#表结构操作" class="headerlink" title="表结构操作"></a>表结构操作</h3><ul>
<li>显示当前的数据库：<code>SELECT DATABASE();</code></li>
<li>选择数据库：<code>USE dbName;</code></li>
<li><p>在当前数据库中创建一个表：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</div><div class="line">    gender <span class="built_in">varchar</span>(<span class="number">10</span>),</div><div class="line">    birthday <span class="built_in">date</span>,</div><div class="line">    entry_date <span class="built_in">date</span>,</div><div class="line">    job <span class="built_in">varchar</span>(<span class="number">100</span>),</div><div class="line">    salary <span class="built_in">float</span>(<span class="number">8</span>,<span class="number">2</span>),</div><div class="line">    <span class="keyword">resume</span> <span class="built_in">text</span></div><div class="line">);</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span>,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</div><div class="line">    <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">100</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>查看库中的所有表：<code>SHOW TABLES;</code></p>
</li>
<li>查看表的结构：<code>DESC employee;</code></li>
<li>查看表的创建细节：<code>SHOW CREATE TABLE employee;</code></li>
<li>在表employee中增加一个image列：<code>ALTER TABLE employee ADD image blob;</code></li>
<li>修改job列，使其长度为60：<code>ALTER TABLE employee MODIFY job varchar(60);</code></li>
<li>删除image列：<code>ALTER TABLE employee DROP image;</code></li>
<li>更改表名，改为user：<code>RENAME TABLE employee TO user;</code></li>
<li>修改表的字符集为utf8：<code>ALTER TABLE user CHARACTER SET utf8;</code></li>
<li>列名name修改为username：<br><code>ALTER TABLE user CHANGE name username varchar(100);</code></li>
<li>查看表中的所有记录：<code>SELECT * FROM user;</code></li>
<li><p>使用INSERT语句向表中插入记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (</div><div class="line">    <span class="number">1</span>,<span class="string">'zxn'</span>,<span class="string">'female'</span>,<span class="string">'1995-12-02'</span>,<span class="string">'2014-09-6'</span>,</div><div class="line">    <span class="string">'CEO'</span>,<span class="number">100000</span>,<span class="string">'beauty'</span></div><div class="line">);`</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> </div><div class="line">    (<span class="keyword">id</span>,username,gender,birthday,entry_date,job,salary,<span class="keyword">resume</span>)</div><div class="line"><span class="keyword">VALUES</span> (</div><div class="line"><span class="number">2</span>,<span class="string">'lyx'</span>,<span class="string">'male'</span>,<span class="string">'1945-12-02'</span>,<span class="string">'2014-09-16'</span>,</div><div class="line"><span class="string">'UFO'</span>,<span class="number">100000</span>,<span class="string">'beates'</span></div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>插入中文数据：<code>mysql&gt; SHOW VARIABLES LIKE &#39;character%&#39;;</code>，显示如下：</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">| character_set_client     | utf8   *客户端使用的编码</div><div class="line">| character_set_connection | utf8   DB连接时使用的编码</div><div class="line">| character_set_database   | utf8   数据库用的编码</div><div class="line">| character_set_results    | utf8   *查询结果集用的编码</div><div class="line">| character_set_server     | utf8   服务器使用的编码</div><div class="line">| character_set_system     | utf8   系统使用的编码</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;因此，<strong>使用命令行要插入中文数据</strong>时，需要告知服务器客户端使用的编码：<code>SET character_set_client=gbk;</code>。同时告知服务器返回的结果集请使用<strong>UTF8</strong>：<br><code>SET character_set_results=gbk;</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (<span class="keyword">id</span>,username,gender,birthday,entry_date,job,salary,<span class="keyword">resume</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'杜小文'</span>,<span class="string">'male'</span>,<span class="string">'1935-12-02'</span>,<span class="string">'2014-09-16'</span>,<span class="string">'CTO'</span>,<span class="number">100000</span>,<span class="string">'杜总'</span>);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;相关操作如下：</p>
<ul>
<li>将所有员工薪水修改为5000元：<br><code>UPDATE user SET salary=5000;</code></li>
<li>将姓名为’zxn’的员工薪水修改为3000元：<br><code>UPDATE user SET salary=3000 WHERE username=&#39;zxn&#39;;</code></li>
<li>将姓名为’lyx’的员工薪水修改为4000元,job改为ccc：<br><code>UPDATE user SET salary=4000,job=&#39;OOO&#39; WHERE username=&#39;lyx&#39;;</code></li>
<li>将杜小文的薪水在原有基础上增加1000元：<br><code>UPDATE user SET salary=salary+1000 WHERE username=&#39;杜小文&#39;;</code></li>
<li>删除表中名称为’zxn’的记：<br><code>DELETE FROM user WHERE username=&#39;zxn&#39;;</code></li>
<li>删除表中所有记录：<br><code>DELETE FROM user;#一条一条的删除</code></li>
<li>使用truncate删除表中记录：<br><code>TRUNCATE TABLE user;#摧毁整张表格，重新建立表结构#</code></li>
</ul>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><ul>
<li>查询表中所有学生的信息：<br><code>SELECT * FROM student;</code></li>
<li>查询表中所有学生的姓名和对应的英语成绩：<br><code>SELECT name,english FROM student;</code></li>
<li>过滤表中重复数据：<br><code>SELECT DISTINCT english FROM student;</code></li>
<li>在所有学生数学分数上加10分特长分：<br><code>SELECT name,math+10 FROM student;</code></li>
<li>统计每个学生的总分：<br><code>SELECT name,chinese+english+math FROM student;</code></li>
<li>使用别名表示学生分数：<br><code>SELECT name AS 姓名,chinese+english+math 总分 FROM student;</code></li>
<li>查询姓名为王五的学生成绩：<br><code>SELECT * FROM student WHERE name=&#39;王五&#39;;</code></li>
<li>查询英语成绩大于90分的同学：<br><code>SELECT * FROM student WHERE english&gt;90;</code></li>
<li>查询总分大于200分的所有同学：<br><code>SELECT * FROM student WHERE (chinese+english+math)&gt;200;</code></li>
<li>查询英语分数在 80－90之间的同学：<br><code>SELECT * FROM student WHERE english BETWEEN 80 AND 90;</code></li>
<li>查询数学分数为89,90,91的同学：<br><code>SELECT * FROM student WHERE math IN (89,90,91);</code></li>
<li>查询所有姓李的学生成绩：<br><code>SELECT * FROM student WHERE name LIKE &#39;李%&#39;;</code></li>
<li>查询数学分&gt;80，语文分&gt;80的同学：<br><code>SELECT * FROM student WHERE math&gt;80 AND chinese&gt;80;</code></li>
<li>对数学成绩排序后输出：<br><code>SELECT name,math FROM student ORDER by math;</code></li>
<li>对总分排序后输出，然后再按从高到低的顺序输出：<br><code>SELECT name AS 姓名,chinese+english+math 总分 FROM student ORDER BY 总分 DESC;</code></li>
<li>对姓李的学生成绩排序输出：<br><code>SELECT * FROM student WHERE name LIKE &#39;李%&#39; ORDER BY chinese;</code></li>
</ul>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>&emsp;&emsp;数据的<strong>完整性</strong>指的是数据的<strong>可靠性</strong>和<strong>准确性</strong>。MySQL数据库中每个字段都可以包含附加约束或修饰符，这些修饰可以增加对所输入数据的检测和限制，进而保证数据的正确性。<br>数据的完整性可分为以下4类：</p>
<ol>
<li><p><strong>实体完整性</strong>（<strong>行完整性</strong>）</p>
<ul>
<li>规定表的每一条记录是表中唯一的实体。</li>
<li>实体完整性通过唯一性约束，主键约束或表示列属性来保证。</li>
<li><p>主键<strong>PRIMARY KEY</strong>特点：</p>
<ol>
<li>唯一性地标识一行记录</li>
<li>作为一个可以被外键引用的有效对象 </li>
<li>可分为<strong>逻辑主键</strong>和<strong>业务主键</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#方式一</div><div class="line">CREATE TABLE t1(</div><div class="line">    id int PRIMARY KEY,</div><div class="line">    name varchar(100),</div><div class="line">    gender varchar(100),</div><div class="line">    age int</div><div class="line">);</div><div class="line">#方式2</div><div class="line">#优势：可定义联合主键</div><div class="line">CREATE TABLE t2(</div><div class="line">    id int;</div><div class="line">    name varchar(100),</div><div class="line">    gender varchar(100),</div><div class="line">    age int</div><div class="line">);</div><div class="line">#方式3（Recommend）</div><div class="line">CREATE TABLE t3(</div><div class="line">    id int,</div><div class="line">    name varcahr(100),</div><div class="line">    gender varchar(100),</div><div class="line">    age int</div><div class="line">);</div><div class="line">ALTER　TABLE t3 ADD PRIMARY KEY (id);</div><div class="line">#方式4：自动增长的主键(Oracle中没有)</div><div class="line">CREATE TABLE t4(</div><div class="line">    id int PRIMARY KEY AUTO_INCREAMENT,</div><div class="line">    name varchar(100),</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>添加、修改主键的关键字：<strong>MODIFY</strong>、<strong>DROP</strong>、<strong>ADD</strong></p>
</li>
</ul>
</li>
<li><p><strong>域完整性</strong>（<strong>列完整性</strong>）<br>&emsp;&emsp;<strong>域完整性</strong>指的是数据库表中的列（即字段）必须符合某种特定的数据类型或数据格式。换句话说，域完整性限制了数据类型、数据格式以及外键约束，检查约束，默认值定义，非空约束和规则等。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5(</div><div class="line">    username <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span>,</div><div class="line">    gender <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    phonenumber <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span></div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>引用完整性</strong>（<strong>参照完整性</strong>）<br>&emsp;&emsp;引用完整性保持表之间已定义的关系，并确保键值在所有表中一致。相应地，如果一个键值更改了，那么在整个数据库中，对该键值的引用也要进行一致的修改。<br>&emsp;&emsp;关系数据库中的表之间一般是相关的或相互制约的，外键(<strong>FOREIGN KEY</strong>)用于约束表之间的联系。<br>&emsp;&emsp;多表之间的关系包括：</p>
</li>
</ol>
<ul>
<li>一对多（实际开发中最常见，处理最复杂）</li>
<li>多对多</li>
<li>一对一（实际开发中基本不用）<br>外键的操作包括：<ul>
<li>添加外键约束<br><code>ALTER TABLE tablename ADD [CONSTRAINT 外键名] FOREIGN KEY][id](index_col_name,...) REFERENCES foreign_tablename(index_col_name,...);</code></li>
<li>查看外键<br><code>SHOW CREATE TABLE tablename;</code></li>
<li>删除外键<br><code>ALTER TABLE tablename DROP FOREIGN KEY 外键名;</code></li>
</ul>
</li>
</ul>
<ol>
<li><strong>自定义完整性</strong></li>
</ol>
<p>&emsp;&emsp;相关参考代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">%一对多实例</div><div class="line">CREATE TABLE customers(</div><div class="line">    id int,</div><div class="line">    name varchar(100),</div><div class="line">    address varchar(255),</div><div class="line">    PRIMARY KEY (id)</div><div class="line">);</div><div class="line">CREATE TABLE orders(</div><div class="line">    id int,</div><div class="line">    orderLineNumber varchar(100),</div><div class="line">    price float(8,2),</div><div class="line">    status int,</div><div class="line">    customer_id int,</div><div class="line">    PRIMARY KEY(id),</div><div class="line">    CONSTRAINT customer_id_fk FOREIGN KEY(customer_id) REFERENCES customers(id)</div><div class="line">);#'customer_id_fk'为约束名称，在库中要保持唯一</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#多对多实例</div><div class="line">DROP TABLE IF EXISTS `teachers`;</div><div class="line">CREATE TABLE teachers(</div><div class="line">    id int,</div><div class="line">    name varchar(100),</div><div class="line">    salary float(10,2),</div><div class="line">    PRIMARY KEY(id)</div><div class="line">);</div><div class="line">DROP TABLE IF EXISTS `students`;</div><div class="line">CREATE TABLE students(</div><div class="line">    id int,</div><div class="line">    name varchar(100),</div><div class="line">    grade float(10,2),</div><div class="line">    PRIMARY KEY(id)</div><div class="line">);</div><div class="line">DROP TABLE IF EXISTS `teacher_student`;</div><div class="line">CREATE TABLE teacher_student(</div><div class="line">    t_id int,</div><div class="line">    s_id int,</div><div class="line">    PRIMARY KEY(t_id,s_id),</div><div class="line">    CONSTRAINT teacher_id_fk FOREIGN KEY(t_id) REFERENCES teachers(id),</div><div class="line">    CONSTRAINT student_id_fk FOREIGN KEY(s_id) REFERENCES students(id)</div><div class="line">);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多对多表关系结构对应的Java类结构设计</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> salary;</div><div class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</div><div class="line">    <span class="keyword">private</span> List&lt;Student&gt; teachers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ol>
<li><p>链接查询</p>
<ul>
<li>交叉连接：返回两张表记录的笛卡尔积<br><code>SELECT * FROM table1,table2;</code><br><code>SELECT * FROM table1 CROSS JOIN table2;</code></li>
<li>内连接查询<ul>
<li>使用<code>INNER JOIN</code>,<code>ON</code>实现内连接查询；</li>
<li>直接连接两个或多个表，在<code>FROM</code>之后查询实现内连接查询；</li>
</ul>
</li>
<li><p>外连接查询</p>
<ul>
<li><strong>左外连接查询</strong>：返回符合连接条件的记录，同时返回左表中不满足连接条件的剩余记录;</li>
<li><strong>右外连接查询</strong>：返回符合连接条件的记录，同时返回右表中不满足连接条件的剩余记录;</li>
<li>允许交换左右的前提下，左外连接查询等同于右外连接查询。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">%内连接</div><div class="line"><span class="keyword">SELECT</span> 字段名列表 <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.字段名=table2.字段名;</div><div class="line"></div><div class="line">%省略INNER关键字</div><div class="line"><span class="keyword">SELECT</span> 字段名列表 <span class="keyword">FROM</span> table1 <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.字段名=table2.字段名;</div><div class="line"><span class="keyword">SELECT</span> 字段名列表 <span class="keyword">FROM</span> table1,table2 <span class="keyword">WHERE</span> 表<span class="number">1.</span>字段名=表<span class="number">2.</span>字段名</div><div class="line">%外连接</div><div class="line"><span class="keyword">SELECT</span> 字段表 <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.字段=table2.字段;</div><div class="line"><span class="keyword">SELECT</span> 字段表 <span class="keyword">FROM</span> table1 <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.字段=table2.字段;</div><div class="line"><span class="keyword">SELECT</span> a.字段<span class="number">1</span>, b.字段<span class="number">1</span> <span class="keyword">FROM</span> table1 <span class="keyword">AS</span> a <span class="keyword">LEFT</span>|<span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> table2 <span class="keyword">AS</span> b <span class="keyword">ON</span> a.字段=b.字段;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>子查询<br>&emsp;&emsp;<strong>子查询</strong>是将一个查询语句嵌套在另一个查询语句中。内层查询语句的查询结果。可以为外层查询语句提供查询条件。通过子查询，可以实现多个表之间的查询。</p>
</li>
<li>子查询关键字</li>
</ol>
<ul>
<li><code>IN</code>/<code>NOT IN</code></li>
<li><code>EXISTS</code>/<code>NOT EXISTS</code></li>
<li><code>ANY</code></li>
<li><code>ALL</code></li>
<li>比较运算符（<code>=</code>、<code>!=</code>、<code>&gt;=</code>、<code>&lt;=</code>）</li>
</ul>
<h3 id="报表查询-amp-分组统计"><a href="#报表查询-amp-分组统计" class="headerlink" title="报表查询&amp;分组统计"></a>报表查询&amp;分组统计</h3><ol>
<li>分组查询<ul>
<li>语法：<code>SELECT ... [WHERE ...][GROUP BY 字段名][HAVING 分组查询条件][ORDER BY 排序条件]</code></li>
<li><strong>HAVING</strong>和<strong>WHERE</strong>均可实现过滤，但<strong>HAVING</strong>通常跟在<strong>GROUP BY</strong>后，它作用于组。同时，HAVING可使用合计函数，但<strong>WHERE</strong>不能用合计函数。</li>
</ul>
</li>
<li>SQL函数<ul>
<li>合计函数</li>
<li>字符串函数</li>
<li>数学函数</li>
<li>日期和时间函数</li>
<li>信息函数</li>
<li>加密函数</li>
<li>其他函数</li>
</ul>
</li>
</ol>
<h3 id="数据库表备份和恢复"><a href="#数据库表备份和恢复" class="headerlink" title="数据库表备份和恢复"></a>数据库表备份和恢复</h3><ul>
<li>备份：<br><code>mysqldump -h localhost -u root -p dbname&gt;backupDir/backupName.sql</code></li>
<li>恢复<ul>
<li><code>mysql&gt;SOURCE d:/mydb1.sql;</code></li>
<li><code>c:/&gt;mysql -u root -p test&lt;d:/mydb1.sql;</code></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本博文记录MySQL的相关学习笔记，欢迎指正。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yaodong.ml/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="http://yaodong.ml/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://yaodong.ml/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>pandas学习笔记</title>
    <link href="http://yaodong.ml/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yaodong.ml/pandas学习笔记.html</id>
    <published>2016-11-02T12:12:28.000Z</published>
    <updated>2016-11-02T12:17:53.683Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;pandas是python环境中基于numpy构建的数据分析、数据处理框架。正是pandas的存在，使得ppython语言在数据分析领域变得强大而高效。<br><a id="more"></a><br>&emsp;&emsp;本博文主要是记录博主学习pandas的相关笔记，大部分学习内容来自于总结<a href="http://pandas.pydata.org/pandas-docs/stable/tutorials.html" target="_blank" rel="external">pandas documenation</a>和《利用Python进行数据分析》的pandas的相关章节。<br>&emsp;&emsp;pandas中的两个主要的数据结构是<strong>Series</strong>和<strong>DataFrame</strong>，对此不做过多的理论介绍，<strong>本博文侧重于记录如何使用pandas</strong>。</p>
<h4 id="导入pandas、numpy、matplotlib包："><a href="#导入pandas、numpy、matplotlib包：" class="headerlink" title="导入pandas、numpy、matplotlib包："></a>导入pandas、numpy、matplotlib包：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</div><div class="line"><span class="keyword">import</span> matplot.pyplot <span class="keyword">as</span> plt</div></pre></td></tr></table></figure>
<h4 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建<strong>Series</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,np.nan,<span class="number">6</span>,<span class="number">8</span>])</div><div class="line">%<span class="comment">#Series具有index属性和values属性，索引从0开始。创建Series时也可指定index的类型</span></div><div class="line">obj = pd.Series([<span class="number">4</span>,<span class="number">-7</span>,<span class="number">5</span>,<span class="number">3</span>],index=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</div><div class="line">%<span class="comment">#可通过索引值获取Series结构的值：</span></div><div class="line">series[index]</div></pre></td></tr></table></figure>
<h4 id="根据字典创建DataFrame对象："><a href="#根据字典创建DataFrame对象：" class="headerlink" title="根据字典创建DataFrame对象："></a>根据字典创建<strong>DataFrame</strong>对象：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(</div><div class="line">    &#123; <span class="string">'A'</span> : <span class="number">1.</span>,</div><div class="line">      <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</div><div class="line">      <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</div><div class="line">      <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</div><div class="line">      <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</div><div class="line">      <span class="string">'F'</span> : <span class="string">'foo'</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h4 id="使用pandas创建时间日期戳对象："><a href="#使用pandas创建时间日期戳对象：" class="headerlink" title="使用pandas创建时间日期戳对象："></a>使用pandas创建时间日期戳对象：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">6</span>]: dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</div><div class="line">In [<span class="number">7</span>]: dates</div><div class="line">Out[<span class="number">7</span>]: </div><div class="line">DatetimeIndex([<span class="string">'2013-01-01'</span>, <span class="string">'2013-01-02'</span>, <span class="string">'2013-01-03'</span>, <span class="string">'2013-01-04'</span>,</div><div class="line">               <span class="string">'2013-01-05'</span>, <span class="string">'2013-01-06'</span>],</div><div class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</div><div class="line">In [<span class="number">8</span>]: df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), index=dates, columns=list(<span class="string">'ABCD'</span>))</div><div class="line">In [<span class="number">9</span>]: df</div><div class="line">Out[<span class="number">9</span>]: </div><div class="line">                A         B         C         D</div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span></div><div class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span> <span class="number">-1.478427</span>  <span class="number">0.524988</span></div></pre></td></tr></table></figure>
<h4 id="对DataFrame对象进行排序"><a href="#对DataFrame对象进行排序" class="headerlink" title="对DataFrame对象进行排序"></a>对DataFrame对象进行排序</h4><p>&emsp;&emsp;根据属性进行排序：<code>sort_index(axis=1,ascending=False)</code>函数<br>&emsp;&emsp;根据某个属性的值进行排序：<code>sort_values(by=&#39;column_name&#39;)</code>函数</p>
<h4 id="获取DataFrame对象的指定行或列"><a href="#获取DataFrame对象的指定行或列" class="headerlink" title="获取DataFrame对象的指定行或列"></a>获取DataFrame对象的指定行或列</h4><p>&emsp;&emsp;df.loc()：根据元素的具体值获取DataFrame对象的行或列<br>&emsp;&emsp;df.iloc()：根据具体数字作为索引来获取DataFrame对象的行或列<br>&emsp;&emsp;df.at()：获取指定的元素<br>&emsp;&emsp;df.iat()：获取指定的元素</p>
<h4 id="pandas处理缺失值"><a href="#pandas处理缺失值" class="headerlink" title="pandas处理缺失值"></a>pandas处理缺失值</h4><p>&emsp;&emsp;df.dropna(how=”any”)：删除DataFrame对象的缺失值<br>&emsp;&emsp;df.fillna(value=5)：用value的值来代替DataFrame对象的缺失值<br>&emsp;&emsp;pd.isnull(df)：判断DataFrame对象的各属性值是否为空</p>
<h4 id="pandas合并、连结DataFrame对象"><a href="#pandas合并、连结DataFrame对象" class="headerlink" title="pandas合并、连结DataFrame对象"></a>pandas合并、连结DataFrame对象</h4><p>&emsp;&emsp;<strong>pd.concat([df1,df2],axis=0 or 1)</strong><br>&emsp;&emsp;<strong>pd.merge()</strong>：类SQL式合并DataFrame对象<br>&emsp;&emsp;<strong>df.append(series, ignore_index=True)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">77</span>]: left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>], <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</div><div class="line">In [<span class="number">78</span>]: right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>], <span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</div><div class="line">In [<span class="number">79</span>]: left</div><div class="line">Out[<span class="number">79</span>]: </div><div class="line">               key  lval</div><div class="line">            <span class="number">0</span>  foo     <span class="number">1</span></div><div class="line">            <span class="number">1</span>  foo     <span class="number">2</span></div><div class="line">In [<span class="number">80</span>]: right</div><div class="line">Out[<span class="number">80</span>]: </div><div class="line">               key  rval</div><div class="line">            <span class="number">0</span>  foo     <span class="number">4</span></div><div class="line">            <span class="number">1</span>  foo     <span class="number">5</span></div><div class="line">In [<span class="number">81</span>]: pd.merge(left, right, on=<span class="string">'key'</span>)</div><div class="line">Out[<span class="number">81</span>]: </div><div class="line">               key  lval  rval</div><div class="line">            <span class="number">0</span>  foo     <span class="number">1</span>     <span class="number">4</span></div><div class="line">            <span class="number">1</span>  foo     <span class="number">1</span>     <span class="number">5</span></div><div class="line">            <span class="number">2</span>  foo     <span class="number">2</span>     <span class="number">4</span></div><div class="line">            <span class="number">3</span>  foo     <span class="number">2</span>     <span class="number">5</span></div></pre></td></tr></table></figure>
<h4 id="pandas的DataFrame对象的相关属性"><a href="#pandas的DataFrame对象的相关属性" class="headerlink" title="pandas的DataFrame对象的相关属性"></a><strong>pandas的DataFrame对象的相关属性</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">df2.A                  df2.boxplot</div><div class="line">df2.abs                df2.C</div><div class="line">df2.add                df2.clip</div><div class="line">df2.add_prefix         df2.clip_lower</div><div class="line">df2.add_suffix         df2.clip_upper</div><div class="line">df2.align              df2.columns</div><div class="line">df2.all                df2.combine</div><div class="line">df2.any                df2.combineAdd</div><div class="line">df2.append             df2.combine_first</div><div class="line">df2.apply              df2.combineMult</div><div class="line">df2.applymap           df2.compound</div><div class="line">df2.as_blocks          df2.consolidate</div><div class="line">df2.asfreq             df2.convert_objects</div><div class="line">df2.as_matrix          df2.copy</div><div class="line">df2.astype             df2.corr</div><div class="line">df2.at                 df2.corrwith</div><div class="line">df2.at_time            df2.count</div><div class="line">df2.axes               df2.cov</div><div class="line">df2.B                  df2.cummax</div><div class="line">df2.between_time       df2.cummin</div><div class="line">df2.bfill              df2.cumprod</div><div class="line">df2.blocks             df2.cumsum</div><div class="line">df2.bool               df2.D</div></pre></td></tr></table></figure>
<h4 id="pandas的相关函数："><a href="#pandas的相关函数：" class="headerlink" title="pandas的相关函数："></a>pandas的相关函数：</h4><p>&emsp;&emsp;<strong>pd.Tiimestamp()</strong>：把字符串转化为日期时间戳对象<br>&emsp;&emsp;<strong>np.array()</strong>：创建numpy的ndarray对象<br>&emsp;&emsp;<strong>df.dtypes</strong>：查看DataFrame对象的每个属性的数据类型<br>&emsp;&emsp;<strong>df.head()</strong>：查看DataFrame对象头部的若干条记录<br>&emsp;&emsp;<strong>df.tail()</strong>：查看DataFrame对象尾部的若干条记录<br>&emsp;&emsp;<strong>df.columns</strong>：获取DataFrame对象的属性名字<br>&emsp;&emsp;<strong>df.index</strong>：获取DataFrame对象的索引值<br>&emsp;&emsp;<strong>df.values</strong>：获取DataFrame对象属性值<br>&emsp;&emsp;<strong>df.describe()</strong>：获取DataFrame对象的相关信息<br>&emsp;&emsp;<strong>df.copy()</strong>：显性复制DataFrame对象<br>&emsp;&emsp;<strong>series.shift()</strong>：对Series对象的数据循环移动n位<br>&emsp;&emsp;<strong>df.apply(</strong>lambda function<strong>)</strong>：对DataFrame对象应用函数<br>&emsp;&emsp;<strong>series.value_counts()</strong>：统计Series对象的每个取值的频数<br>&emsp;&emsp;<strong>series.str.lower()</strong>：把字符转化为小写<br>&emsp;&emsp;<strong>df.groupby(column_name).sum()</strong>：以group的形式统计相关信息<br>&emsp;&emsp;stacked = df.stack()：<br>&emsp;&emsp;stacked.unstack()</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;pandas是python环境中基于numpy构建的数据分析、数据处理框架。正是pandas的存在，使得ppython语言在数据分析领域变得强大而高效。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yaodong.ml/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Window下python的Xgboost框架安装教程</title>
    <link href="http://yaodong.ml/Window%E4%B8%8Bpython%E7%9A%84Xgboost%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B.html"/>
    <id>http://yaodong.ml/Window下python的Xgboost框架安装教程.html</id>
    <published>2016-10-14T11:43:42.000Z</published>
    <updated>2016-11-02T12:19:47.668Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="http://xgboost.readthedocs.io/en/latest/" target="_blank" rel="external">Xgboost</a>是<a href="http://homes.cs.washington.edu/~tqchen/" target="_blank" rel="external">Tianqi Chen</a>大神实现的一个boost算法框架。在Kaggle比赛的很多题目中都大放异彩，Xgboost诞生之后获奖无数，是个值得强力推荐的机器学习实战框架。<br><a id="more"></a><br>&emsp;&emsp;本博文记录了在Windows平台下的Anaconda中安装Xgboost。Window平台对机器学习、深度学习的最新成果的支持与Linux/Ubuntu的差距简直不要太大，安装过程中也踩了不少坑。本博文特将Xgboost的安装过程作简单整理，希望对大家能够有所帮助。<br>&emsp;&emsp;果冻君的电脑配置环境是：</p>
<ul>
<li>操作系统：Window 8.1 <strong>64</strong>位</li>
<li>已经安装了<strong>git</strong>和<strong>Anaconda2</strong>，<strong>git</strong>和<strong>Anaconda2</strong>就不多说了，学习的两大利器，强力推荐！</li>
</ul>
<hr>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><ol>
<li><p>在用户文件夹下建立code文件夹</p>
</li>
<li><p>进入code文件夹，使用git将xgboost克隆到本地</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/code</div><div class="line">git clone --recursive https://github.com/dmlc/xgboost</div></pre></td></tr></table></figure>
</li>
<li><p>进入xgboost文件夹，输入下面的两条指令：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout 9a48a40 %为了解决在源码编译时出现问题</div><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure>
</li>
<li><p>window下安装Xgboost需要对源码进行编译，编译工具一定要使用Mingw64。去<a href="http://mingw-w64.org/doku.php" target="_blank" rel="external">官网</a>下载Mingw64。<code>MinGW-w64 - for 32 and 64 bit Windows</code>的下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/" target="_blank" rel="external">Download mingw-w64-install.exe</a>。这里需要注意，<strong>安装mingw64的5.3.0或4.9.x版本，不要安装最新的6.1.0和6.2.0版本，否则会编译不成功</strong>！！！，如图说示：<br><img src="/images/mingw64-5.3.0.png" alt="mingw64-5.3.0"></p>
</li>
<li>mingw64安装成功后，一会儿要用到<code>mingw32-make.exe</code>编译Xgboost的源码，因此需要将<code>mingw32-make.exe</code>的路径加入到环境变量<code>PATH</code>中：<code>C:\Program Files\mingw-w64\x86_64-5.3.0-posix-seh-rt_v5-rev0\mingw64\bin</code>。重启Git Bash窗口，输入<code>which mingw32-make</code>，如果输出<code>mingw32-make</code>的安装路径，则说明环境变量配置成功。</li>
<li><p>在Git Bash窗口输入以下指令，使用<code>mingw32-make</code>编译Xgboost的几个子模块。注意当输入的指令完全执行完后再输入下一条指令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ alias make=&apos;mingw32-make&apos;</div><div class="line">$ cd dmlc-core</div><div class="line">$ make -j4</div><div class="line">$ cd ../rabit</div><div class="line">$ make lib/librabit_empty.a -j4</div><div class="line">$ cd ..</div><div class="line">$ cp make/mingw64.mk config.mk</div><div class="line">$ make -j4</div></pre></td></tr></table></figure>
</li>
<li><p>打开<code>Anaconda prompt</code>窗口，进入xgboost/python-package路径，执行以下指令；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Anaconda2] cd C:\Users\username\code\xgboost\python-package </div><div class="line">[Anaconda2] python setup.py install</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Xgboost</strong>到这里已经安装成功了，不过此时若在python程序中<code>import xgboost as xgb</code>时，会出现Error。因此还需要把<code>mingw64</code>的路径加入到环境变量的Path中：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">mingw_path = <span class="string">'C:\\Program Files\\mingw-w64\\x86_64-5.3.0-posix-seh-rt_v4-rev0\\mingw64\\bin'</span></div><div class="line">os.environ[<span class="string">'PATH'</span>] = mingw_path + <span class="string">';'</span> + os.environ[<span class="string">'PATH'</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>尝试在python程序中输入<code>import xgboost as xgb</code>，如果没有报错，则说明我们的Xgboost安装成功啦！Enjoy it~~~</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;http://xgboost.readthedocs.io/en/latest/&quot;&gt;Xgboost&lt;/a&gt;是&lt;a href=&quot;http://homes.cs.washington.edu/~tqchen/&quot;&gt;Tianqi Chen&lt;/a&gt;大神实现的一个boost算法框架。在Kaggle比赛的很多题目中都大放异彩，Xgboost诞生之后获奖无数，是个值得强力推荐的机器学习实战框架。&lt;br&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yaodong.ml/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="动手实战" scheme="http://yaodong.ml/tags/%E5%8A%A8%E6%89%8B%E5%AE%9E%E6%88%98/"/>
    
      <category term="Xgboost" scheme="http://yaodong.ml/tags/Xgboost/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning学习资源总结</title>
    <link href="http://yaodong.ml/Machine-Learning%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%80%BB%E7%BB%93.html"/>
    <id>http://yaodong.ml/Machine-Learning学习资源总结.html</id>
    <published>2016-10-14T01:55:27.000Z</published>
    <updated>2016-11-02T08:17:09.830Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>&emsp;&emsp;</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Machine Learning学习笔记：特征工程</title>
    <link href="http://yaodong.ml/Machine-Learning%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B.html"/>
    <id>http://yaodong.ml/Machine-Learning学习笔记：特征工程.html</id>
    <published>2016-10-10T08:48:47.000Z</published>
    <updated>2016-10-10T10:40:34.485Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>特征工程（Feature Engineering）</strong>包括特征构建(<strong>Construction</strong>)、特征提取(<strong>Extraction</strong>)、特征选择(<strong>Selection</strong>)三个部分。本博文简单记录了特征工程的相关知识和实战应用经验。<br><a id="more"></a></p>
<blockquote>
<p><strong>Feature engineering</strong> is the process of using domain knowledge of the data to create features that make machine learning algorithms work. Feature engineering is fundamental to the application of machine learning, and is both difficult and expensive. The need for manual feature engineering can be obviated by automated feature learning<br><strong>特征工程</strong>是利用数据科学领域的相关知识来创建、提取、选择能使机器学习算法达到最佳性能的特征的过程。</p>
</blockquote>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>&emsp;&emsp;特征选择，即从特征集合中挑选一组最具统计意义的特征子集，以提高机器学习算法的性能表现，并达到数据降维的效果。通常需要衡量单独每个特征与类别标签之间的相关性。实际机器学习应用中，表示单个特征与类别标签之间相关关系的参数指标有：<strong>皮尔逊相关系数</strong>、<strong>信息增益</strong>、<strong>信息增益比</strong>和<strong>基尼指数</strong>等。</p>
<h4 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h4><p>&emsp;&emsp;两个变量（特征与标签向量）之间的pearson相关系数定义为两个变量之间的协方差和标准差的商。计算公式为：</p>
<script type="math/tex; mode=display">\gamma^2_{xy}=\dfrac{cov(x,y)}{\sigma_x\sigma_y}=\dfrac{E[(X-\mu_x)(Y-\mu_y)]}{\sigma_x\sigma_y}</script><p>&emsp;&emsp;这里的$x$表示某个特征的观测值，$Y$表示类别标签。pearson相关系数的取值在0到1之间。</p>
<h4 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h4><p>&emsp;&emsp;信息增益的概念来源于信息科学的分支。<strong>熵</strong>（entropy）是随机变量不确定性的度量。熵越大，表示随机变量的不确定性就越大。<br>设随机变量X为有限个值的离散随机变量，其概率分布为</p>
<script type="math/tex; mode=display">P(X=x_i)=p_i</script><p>&emsp;&emsp;熵的定义为</p>
<script type="math/tex; mode=display">H(X)=-\sum_{i=1}^np_ilog(p_i)</script><p>&emsp;&emsp;条件熵：H(Y|X)表示已知随机变量X的条件下随机变量Y的不确定性，定义<script type="math/tex">H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)</script><br>&emsp;&emsp;其中$p_i=P(X=x_i)$。这里X表示样本数据集的某个特征，即表示根据某个特征划分后，数据Y的熵。如果某个特征有更强的分类能力，则条件熵$H(Y|X)$越小，表示不确定性越小。</p>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>&emsp;&emsp;信息增益定义为特征A对训练数据集D的信息增益 $g(D,A)$ 定义为集合D的经验熵 $H(D)$ 与特征A在给定条件下D的经验条件熵$H(D|A)$之差，即<script type="math/tex">g(D,A)=H(D)-H(D|A)</script><br> &emsp;&emsp;信息增益$g(D,A)$表示特征A使得对数据集D的分裂的不确定性减少的程度。所以信息增益越大，表明不确定性减小越多，即特征具有更强的分类能力。<br>&emsp;&emsp;根据信息增益准则的特征选择方法是：对训练数据集（或其子集）D,计算每个特征的信息增益，并比较其大小将其排序，选择最大的信息增益对应的特征。</p>
<h4 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h4><p>&emsp;&emsp;信息增益比也是度量特征分类能力的方法。特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益与训练数据集D关于特征A的熵之比，即</p>
<script type="math/tex; mode=display">g_R(D,A)=\frac{g(D,A)}{H_A(D)}</script><p>&emsp;&emsp;其中</p>
<script type="math/tex; mode=display">H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}</script><p>&emsp;&emsp;$|D|$表示训练样本集D中样本数量，$|D_i|$表示训练数据D中特征A取第i个值的总数目。信息增益比越大，表明特征分类能力越强。<br>&emsp;&emsp;需要注意的是，<strong>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题</strong>。</p>
<h4 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h4><p>&emsp;&emsp;基尼指数表示样本集合的不确定性程度，基尼指数越小，对应的特征分类能力越强。</p>
<h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>&emsp;&emsp;原则上讲，特征提取应该在特征选择之前。特征提取的对象是未经处理的原始数据（raw data），它的目的是自动地构建新的特征，将原始数据转换为一组具有明显物理现实意义或者统计意义或核的特征。实际的机器学习应用中，常见的特征提取的方法有：</p>
<ul>
<li><strong>PCA</strong>（Principal Component Analysis，主成分分析）</li>
<li><strong>ICA</strong> （Independent component analysis，独立成分分析）</li>
<li><strong>LDA</strong> （Linear Discriminant Analysis，线性判别分析）</li>
</ul>
<h3 id="特征构建"><a href="#特征构建" class="headerlink" title="特征构建"></a>特征构建</h3><p>&emsp;&emsp;特征构建指的是结合所研究问题的实际背景从原始数据中人工构建新的特征。这一步需要花大量的时间和精力去研究真实的数据，思考问题的潜在形式和数据结构，同时能够更好地应用到预测模型中。<br>&emsp;&emsp;特征构建需要很强的洞察力和分析能力，从原始数据中找出具有物理意义的特征，并将其处理成一个或一组新的特征，便于应用到机器学习算法模型中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;特征工程包括特征提取、特征构建和特征选择这三个子问题。在实际的机器学习应用中，每一个步骤都很重要。将这三个子问题的重要性排序为：<script type="math/tex">特征构建>特征提取>特征选择</script><br>如果特征构建做的不好，则会直接影响特征提取，进而影响了特征选择，最终影响机器学习算法模型的性能表现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;特征工程（Feature Engineering）&lt;/strong&gt;包括特征构建(&lt;strong&gt;Construction&lt;/strong&gt;)、特征提取(&lt;strong&gt;Extraction&lt;/strong&gt;)、特征选择(&lt;strong&gt;Selection&lt;/strong&gt;)三个部分。本博文简单记录了特征工程的相关知识和实战应用经验。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yaodong.ml/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yaodong.ml/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://yaodong.ml/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning学习笔记：判别模型与生成模型</title>
    <link href="http://yaodong.ml/Machine-Learning%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://yaodong.ml/Machine-Learning学习笔记：判别模型与生成模型.html</id>
    <published>2016-10-08T10:43:52.000Z</published>
    <updated>2016-10-08T11:01:45.356Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本博文简单介绍了判别模型与生成模型的定义、优缺点以及相互之间的关系。<br><a id="more"></a></p>
<h3 id="生成模型和判别模型的定义"><a href="#生成模型和判别模型的定义" class="headerlink" title="生成模型和判别模型的定义"></a>生成模型和判别模型的定义</h3><p>&emsp;&emsp;监督学习的任务就是从数据中学习一个模型（也叫分类器），对给定的输入<strong>X</strong>预测相应的输出<strong>Y</strong>。决策函数为<strong>Y=<em>f</em>(X)</strong>或者条件概率分布<strong>P(Y|X)</strong>。实际上通过条件概率分布<strong>P(Y|X)</strong>进行预测也是隐含着表达成决策函数<strong>Y=<em>f</em>(X)</strong>的形式的。<br>&emsp;&emsp;监督学习方法分为<strong>生成方法</strong>（Generative approach）和<strong>判别方法</strong>（Discriminative approach），相应的机器学习模型分别称为<strong>生成模型</strong>（Generative Model）和<strong>判别模型</strong>（Discriminative Model）：</p>
<ul>
<li><strong>判别模型</strong>：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。<strong>基本思想</strong>是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。典型的判别模型包括<strong>k近邻</strong>，<strong>感知级</strong>，<strong>决策树</strong>，<strong>支持向量机</strong>等。</li>
<li><strong>生成模型</strong>：由数据学习联合概率密度分布<strong>P(X,Y)</strong>，然后求出条件概率分布<strong>P(Y|X)</strong>作为预测的模型，即生成模型：<strong>P(Y|X)= P(X,Y)/ P(X)</strong>。基本思想是首先建立样本的联合概率概率密度模型<strong>P(X,Y)</strong>，然后再得到后验概率<strong>P(Y|X)</strong>，再利用它进行分类。注意是先求<strong>P(X,Y)</strong>才得到<strong>P(Y|X)</strong>的，这个过程还要先求出<strong>P(X)</strong>。<strong>P(X)</strong>就是你的训练样本数据的概率分布。当数据样本非常多时，得到的<strong>P(X)</strong>才能很好的描述你数据真正的分布。典型的生成模型有：<strong>朴素贝叶斯</strong>和<strong>隐马尔科夫模型</strong>等。<h3 id="生成模型和判别模型的优缺点"><a href="#生成模型和判别模型的优缺点" class="headerlink" title="生成模型和判别模型的优缺点"></a>生成模型和判别模型的优缺点</h3>&emsp;&emsp;<strong>生成模型</strong>的特点：</li>
</ul>
<ul>
<li>生成方法学习联合概率密度分布<strong>P(X,Y)</strong>，所以可以从统计学的角度表示数据的分布情况，能够反映同类数据本身的相似度，但它不关心到底划分各类的分类边界在哪；生成方法可以还原出联合概率分布P(Y|X)，而判别方法不能；</li>
<li>生成方法的学习收敛速度更快，即当样本容量增加的时候，学习模型可以更快的收敛于真实模型，当存在隐变量时，仍可以用生成方法学习。此时判别方法就不能用。</li>
</ul>
<p>&emsp;&emsp;<strong>判别模型</strong>的特点：</p>
<ul>
<li>判别模型直接学习决策函数<strong>Y=<em>f</em>(X)</strong>或者条件概率分布<strong>P(Y|X)</strong>，因此不能反映训练数据本身的特性；</li>
<li>但它寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。</li>
<li>直接面对预测，往往学习的准确率更高。</li>
<li>由于直接学习<strong>P(Y|X)</strong>或<strong>P(X)</strong>，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</li>
</ul>
<h3 id="生成模型和判别模型的联系"><a href="#生成模型和判别模型的联系" class="headerlink" title="生成模型和判别模型的联系"></a>生成模型和判别模型的联系</h3><p>&emsp;&emsp;<strong>由生成模型可以得到判别模型，但由判别模型得不到生成模型</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本博文简单介绍了判别模型与生成模型的定义、优缺点以及相互之间的关系。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yaodong.ml/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yaodong.ml/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://yaodong.ml/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE很全面的面试题（转自jackfrued）</title>
    <link href="http://yaodong.ml/Java%20EE%E5%BE%88%E5%85%A8%E9%9D%A2%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E8%BD%AC%E8%87%AAjackfrued%EF%BC%89.html"/>
    <id>http://yaodong.ml/Java EE很全面的面试题（转自jackfrued）.html</id>
    <published>2016-10-08T08:06:29.000Z</published>
    <updated>2016-10-14T11:53:55.810Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Java面试题在google上能搜到很多，但是绝大部分博客或网站上的Java面试题都不全面。<strong>本博客非原创</strong>，博主果冻君作为一只<strong>搬运工</strong>，本博客<strong>汇总</strong>了CSDN博客上<a href="http://my.csdn.net/jackfrued" target="_blank" rel="external">jackfrued</a>的Java面试题全集。<br><a id="more"></a><br>&nbsp;<br>&emsp;&emsp;本博客只汇总了此大神博客上的Java面试题目，具体答案请移步原著博客：</p>
<ul>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="external">Java面试题全集（上）</a></li>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44931137" target="_blank" rel="external">Java面试题全集（中）</a></li>
<li><a href="http://blog.csdn.net/jackfrued/article/details/44931161" target="_blank" rel="external">Java面试题全集（下）</a></li>
</ul>
<h3 id="Java-SE面试题"><a href="#Java-SE面试题" class="headerlink" title="Java SE面试题"></a>Java SE面试题</h3><blockquote>
<p>这部分主要是Java SE相关的面试题，具有很强的通用性，即使不是Java程序员，只要你是Java语言的使用者，这部分都值得一读。</p>
</blockquote>
<h4 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h4><h4 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h4><h4 id="String-是最基本的数据类型吗？"><a href="#String-是最基本的数据类型吗？" class="headerlink" title="String 是最基本的数据类型吗？"></a>String 是最基本的数据类型吗？</h4><h4 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h4><h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h4><h4 id="Java有没有goto？"><a href="#Java有没有goto？" class="headerlink" title="Java有没有goto？"></a>Java有没有goto？</h4><h4 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h4><h4 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h4><h4 id="解释内存中的栈-stack-、堆-heap-和静态区-static-area-的用法。"><a href="#解释内存中的栈-stack-、堆-heap-和静态区-static-area-的用法。" class="headerlink" title="解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。"></a>解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。</h4><h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h4><h4 id="swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#swtich-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h4><h4 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h4><h4 id="数组有没有length-方法？String有没有length-方法？"><a href="#数组有没有length-方法？String有没有length-方法？" class="headerlink" title="数组有没有length()方法？String有没有length()方法？"></a>数组有没有length()方法？String有没有length()方法？</h4><h4 id="在Java中，如何跳出当前的多重嵌套循环？"><a href="#在Java中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java中，如何跳出当前的多重嵌套循环？"></a>在Java中，如何跳出当前的多重嵌套循环？</h4><h4 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h4><h4 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h4><h4 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h4><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h4><h4 id="String和StringBuilder、StringBuffer的区别？"><a href="#String和StringBuilder、StringBuffer的区别？" class="headerlink" title="String和StringBuilder、StringBuffer的区别？"></a>String和StringBuilder、StringBuffer的区别？</h4><h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><h4 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h4><h4 id="char型变量中能不能存贮一个中文汉字，为什么？"><a href="#char型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="char型变量中能不能存贮一个中文汉字，为什么？"></a>char型变量中能不能存贮一个中文汉字，为什么？</h4><h4 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h4><h4 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h4><h4 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h4><h4 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h4><h4 id="阐述静态变量和实例变量的区别。"><a href="#阐述静态变量和实例变量的区别。" class="headerlink" title="阐述静态变量和实例变量的区别。"></a>阐述静态变量和实例变量的区别。</h4><h4 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h4><h4 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h4><h4 id="GC（gabage-collection）是什么？为什么要有GC？"><a href="#GC（gabage-collection）是什么？为什么要有GC？" class="headerlink" title="GC（gabage collection）是什么？为什么要有GC？"></a>GC（gabage collection）是什么？为什么要有GC？</h4><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象？"></a>String s = new String(“xyz”);创建了几个字符串对象？</h4><h4 id="接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h4><h4 id="一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h4><h4 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h4><h4 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h4><h4 id="Java-中的final关键字有哪些用法？"><a href="#Java-中的final关键字有哪些用法？" class="headerlink" title="Java 中的final关键字有哪些用法？"></a>Java 中的final关键字有哪些用法？</h4><h4 id="数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？"><a href="#数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？" class="headerlink" title="数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？"></a>数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？</h4><h4 id="如何实现字符串的反转及替换？"><a href="#如何实现字符串的反转及替换？" class="headerlink" title="如何实现字符串的反转及替换？"></a>如何实现字符串的反转及替换？</h4><h4 id="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h4><h4 id="日期和时间：-如何取得年月日、小时分钟秒？-如何取得从1970年1月1日0时0分0秒到现在的毫秒数？如何取得某月的最后一天？-如何格式化日期？"><a href="#日期和时间：-如何取得年月日、小时分钟秒？-如何取得从1970年1月1日0时0分0秒到现在的毫秒数？如何取得某月的最后一天？-如何格式化日期？" class="headerlink" title="日期和时间： 如何取得年月日、小时分钟秒？ 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？如何取得某月的最后一天？ 如何格式化日期？"></a>日期和时间： 如何取得年月日、小时分钟秒？ 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？如何取得某月的最后一天？ 如何格式化日期？</h4><h4 id="打印昨天的当前时刻"><a href="#打印昨天的当前时刻" class="headerlink" title="打印昨天的当前时刻"></a>打印昨天的当前时刻</h4><h4 id="比较一下Java和JavaSciprt"><a href="#比较一下Java和JavaSciprt" class="headerlink" title="比较一下Java和JavaSciprt"></a>比较一下Java和JavaSciprt</h4><h4 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（assert）？</h4><h4 id="Error和Exception有什么区别？"><a href="#Error和Exception有什么区别？" class="headerlink" title="Error和Exception有什么区别？"></a>Error和Exception有什么区别？</h4><h4 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h4><h4 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h4><h4 id="运行时异常与受检异常有何异同？"><a href="#运行时异常与受检异常有何异同？" class="headerlink" title="运行时异常与受检异常有何异同？"></a>运行时异常与受检异常有何异同？</h4><h4 id="列出一些你常见的运行时异常？"><a href="#列出一些你常见的运行时异常？" class="headerlink" title="列出一些你常见的运行时异常？"></a>列出一些你常见的运行时异常？</h4><h4 id="阐述final、finally、finalize的区别。"><a href="#阐述final、finally、finalize的区别。" class="headerlink" title="阐述final、finally、finalize的区别。"></a>阐述final、finally、finalize的区别。</h4><h4 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h4><h4 id="阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性。</h4><h4 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h4><h4 id="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h4><h4 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h4><h4 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h4><h4 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h4><h4 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h4><h4 id="synchronized关键字的用法？"><a href="#synchronized关键字的用法？" class="headerlink" title="synchronized关键字的用法？"></a>synchronized关键字的用法？</h4><h4 id="举例说明同步和异步。"><a href="#举例说明同步和异步。" class="headerlink" title="举例说明同步和异步。"></a>举例说明同步和异步。</h4><h4 id="启动一个线程是调用run-还是start-方法？"><a href="#启动一个线程是调用run-还是start-方法？" class="headerlink" title="启动一个线程是调用run()还是start()方法？"></a>启动一个线程是调用run()还是start()方法？</h4><h4 id="什么是线程池（thread-pool）？"><a href="#什么是线程池（thread-pool）？" class="headerlink" title="什么是线程池（thread pool）？"></a>什么是线程池（thread pool）？</h4><h4 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h4><h4 id="简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>简述synchronized 和java.util.concurrent.locks.Lock的异同？</h4><h4 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h4><h4 id="Java中有几种类型的流？"><a href="#Java中有几种类型的流？" class="headerlink" title="Java中有几种类型的流？"></a>Java中有几种类型的流？</h4><h4 id="写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"><a href="#写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。" class="headerlink" title="写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。"></a>写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</h4><h4 id="如何用Java代码列出一个目录下所有的文件？"><a href="#如何用Java代码列出一个目录下所有的文件？" class="headerlink" title="如何用Java代码列出一个目录下所有的文件？"></a>如何用Java代码列出一个目录下所有的文件？</h4><h4 id="用Java的套接字编程实现一个多线程的回显（echo）服务器"><a href="#用Java的套接字编程实现一个多线程的回显（echo）服务器" class="headerlink" title="用Java的套接字编程实现一个多线程的回显（echo）服务器"></a>用Java的套接字编程实现一个多线程的回显（echo）服务器</h4><h4 id="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"><a href="#XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？" class="headerlink" title="XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？"></a>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</h4><h4 id="你在项目中哪些地方用到了XML？"><a href="#你在项目中哪些地方用到了XML？" class="headerlink" title="你在项目中哪些地方用到了XML？"></a>你在项目中哪些地方用到了XML？</h4><h4 id="阐述JDBC操作数据库的步骤。"><a href="#阐述JDBC操作数据库的步骤。" class="headerlink" title="阐述JDBC操作数据库的步骤。"></a>阐述JDBC操作数据库的步骤。</h4><h4 id="Statement和PreparedStatement有什么区别？哪个性能更好？"><a href="#Statement和PreparedStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PreparedStatement有什么区别？哪个性能更好？"></a>Statement和PreparedStatement有什么区别？哪个性能更好？</h4><h4 id="使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h4><h4 id="在进行数据库编程时，连接池有什么作用？"><a href="#在进行数据库编程时，连接池有什么作用？" class="headerlink" title="在进行数据库编程时，连接池有什么作用？"></a>在进行数据库编程时，连接池有什么作用？</h4><h4 id="什么是DAO模式？"><a href="#什么是DAO模式？" class="headerlink" title="什么是DAO模式？"></a>什么是DAO模式？</h4><h4 id="事务的ACID是指什么？"><a href="#事务的ACID是指什么？" class="headerlink" title="事务的ACID是指什么？"></a>事务的ACID是指什么？</h4><h4 id="JDBC中如何进行事务处理？"><a href="#JDBC中如何进行事务处理？" class="headerlink" title="JDBC中如何进行事务处理？"></a>JDBC中如何进行事务处理？</h4><h4 id="JDBC能否处理Blob和Clob？"><a href="#JDBC能否处理Blob和Clob？" class="headerlink" title="JDBC能否处理Blob和Clob？"></a>JDBC能否处理Blob和Clob？</h4><h4 id="简述正则表达式及其用途。"><a href="#简述正则表达式及其用途。" class="headerlink" title="简述正则表达式及其用途。"></a>简述正则表达式及其用途。</h4><h4 id="Java中是如何支持正则表达式操作的？"><a href="#Java中是如何支持正则表达式操作的？" class="headerlink" title="Java中是如何支持正则表达式操作的？"></a>Java中是如何支持正则表达式操作的？</h4><h4 id="获得一个类的类对象有哪些方式？"><a href="#获得一个类的类对象有哪些方式？" class="headerlink" title="获得一个类的类对象有哪些方式？"></a>获得一个类的类对象有哪些方式？</h4><h4 id="如何通过反射创建对象？"><a href="#如何通过反射创建对象？" class="headerlink" title="如何通过反射创建对象？"></a>如何通过反射创建对象？</h4><h4 id="如何通过反射获取和设置对象私有字段的值？"><a href="#如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="如何通过反射获取和设置对象私有字段的值？"></a>如何通过反射获取和设置对象私有字段的值？</h4><h4 id="如何通过反射调用对象的方法？"><a href="#如何通过反射调用对象的方法？" class="headerlink" title="如何通过反射调用对象的方法？"></a>如何通过反射调用对象的方法？</h4><h4 id="简述一下面向对象的”六原则一法则”。"><a href="#简述一下面向对象的”六原则一法则”。" class="headerlink" title="简述一下面向对象的”六原则一法则”。"></a>简述一下面向对象的”六原则一法则”。</h4><h4 id="简述一下你了解的设计模式。"><a href="#简述一下你了解的设计模式。" class="headerlink" title="简述一下你了解的设计模式。"></a>简述一下你了解的设计模式。</h4><h4 id="用Java写一个单例类。"><a href="#用Java写一个单例类。" class="headerlink" title="用Java写一个单例类。"></a>用Java写一个单例类。</h4><h4 id="什么是UML？"><a href="#什么是UML？" class="headerlink" title="什么是UML？"></a>什么是UML？</h4><h4 id="UML中有哪些常用的图？"><a href="#UML中有哪些常用的图？" class="headerlink" title="UML中有哪些常用的图？"></a>UML中有哪些常用的图？</h4><h4 id="用Java写一个冒泡排序。"><a href="#用Java写一个冒泡排序。" class="headerlink" title="用Java写一个冒泡排序。"></a>用Java写一个冒泡排序。</h4><h4 id="用Java写一个折半查找"><a href="#用Java写一个折半查找" class="headerlink" title="用Java写一个折半查找"></a>用Java写一个折半查找</h4><h3 id="Java-Web面试题"><a href="#Java-Web面试题" class="headerlink" title="Java Web面试题"></a>Java Web面试题</h3><blockquote>
<p>这部分主要是与Java Web和Web Service相关的面试题。</p>
</blockquote>
<h4 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h4><h4 id="Servlet接口中有哪些方法？"><a href="#Servlet接口中有哪些方法？" class="headerlink" title="Servlet接口中有哪些方法？"></a>Servlet接口中有哪些方法？</h4><h4 id="转发（forward）和重定向（redirect）的区别？"><a href="#转发（forward）和重定向（redirect）的区别？" class="headerlink" title="转发（forward）和重定向（redirect）的区别？"></a>转发（forward）和重定向（redirect）的区别？</h4><h4 id="JSP有哪些内置对象？作用分别是什么？"><a href="#JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP有哪些内置对象？作用分别是什么？"></a>JSP有哪些内置对象？作用分别是什么？</h4><h4 id="get和post请求的区别？"><a href="#get和post请求的区别？" class="headerlink" title="get和post请求的区别？"></a>get和post请求的区别？</h4><h4 id="常用的Web服务器有哪些？"><a href="#常用的Web服务器有哪些？" class="headerlink" title="常用的Web服务器有哪些？"></a>常用的Web服务器有哪些？</h4><h4 id="JSP和Servlet是什么关系？"><a href="#JSP和Servlet是什么关系？" class="headerlink" title="JSP和Servlet是什么关系？"></a>JSP和Servlet是什么关系？</h4><h4 id="讲解JSP中的四种作用域。"><a href="#讲解JSP中的四种作用域。" class="headerlink" title="讲解JSP中的四种作用域。"></a>讲解JSP中的四种作用域。</h4><h4 id="如何实现JSP或Servlet的单线程模式？"><a href="#如何实现JSP或Servlet的单线程模式？" class="headerlink" title="如何实现JSP或Servlet的单线程模式？"></a>如何实现JSP或Servlet的单线程模式？</h4><h4 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a>实现会话跟踪的技术有哪些？</h4><h4 id="过滤器有哪些作用和用法？"><a href="#过滤器有哪些作用和用法？" class="headerlink" title="过滤器有哪些作用和用法？"></a>过滤器有哪些作用和用法？</h4><h4 id="监听器有哪些作用和用法？"><a href="#监听器有哪些作用和用法？" class="headerlink" title="监听器有哪些作用和用法？"></a>监听器有哪些作用和用法？</h4><h4 id="web-xml文件中可以配置哪些内容？"><a href="#web-xml文件中可以配置哪些内容？" class="headerlink" title="web.xml文件中可以配置哪些内容？"></a>web.xml文件中可以配置哪些内容？</h4><h4 id="你的项目中使用过哪些JSTL标签？"><a href="#你的项目中使用过哪些JSTL标签？" class="headerlink" title="你的项目中使用过哪些JSTL标签？"></a>你的项目中使用过哪些JSTL标签？</h4><h4 id="使用标签库有什么好处？如何自定义JSP标签？"><a href="#使用标签库有什么好处？如何自定义JSP标签？" class="headerlink" title="使用标签库有什么好处？如何自定义JSP标签？"></a>使用标签库有什么好处？如何自定义JSP标签？</h4><h4 id="说一下表达式语言（EL）的隐式对象及其作用。"><a href="#说一下表达式语言（EL）的隐式对象及其作用。" class="headerlink" title="说一下表达式语言（EL）的隐式对象及其作用。"></a>说一下表达式语言（EL）的隐式对象及其作用。</h4><h4 id="表达式语言（EL）支持哪些运算符？"><a href="#表达式语言（EL）支持哪些运算符？" class="headerlink" title="表达式语言（EL）支持哪些运算符？"></a>表达式语言（EL）支持哪些运算符？</h4><h4 id="Java-Web开发的Model-1和Model-2分别指的是什么？"><a href="#Java-Web开发的Model-1和Model-2分别指的是什么？" class="headerlink" title="Java Web开发的Model 1和Model 2分别指的是什么？"></a>Java Web开发的Model 1和Model 2分别指的是什么？</h4><h4 id="Servlet-3中的异步处理指的是什么？"><a href="#Servlet-3中的异步处理指的是什么？" class="headerlink" title="Servlet 3中的异步处理指的是什么？"></a>Servlet 3中的异步处理指的是什么？</h4><h4 id="如何在基于Java的Web项目中实现文件上传和下载？"><a href="#如何在基于Java的Web项目中实现文件上传和下载？" class="headerlink" title="如何在基于Java的Web项目中实现文件上传和下载？"></a>如何在基于Java的Web项目中实现文件上传和下载？</h4><h4 id="服务器收到用户提交的表单数据，到底是调用Servlet的doGet-还是doPost-方法？"><a href="#服务器收到用户提交的表单数据，到底是调用Servlet的doGet-还是doPost-方法？" class="headerlink" title="服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？"></a>服务器收到用户提交的表单数据，到底是调用Servlet的doGet()还是doPost()方法？</h4><h4 id="JSP中的静态包含和动态包含有什么区别？"><a href="#JSP中的静态包含和动态包含有什么区别？" class="headerlink" title="JSP中的静态包含和动态包含有什么区别？"></a>JSP中的静态包含和动态包含有什么区别？</h4><h4 id="Servlet中如何获取用户提交的查询参数或表单数据？"><a href="#Servlet中如何获取用户提交的查询参数或表单数据？" class="headerlink" title="Servlet中如何获取用户提交的查询参数或表单数据？"></a>Servlet中如何获取用户提交的查询参数或表单数据？</h4><h4 id="Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？"><a href="#Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？" class="headerlink" title="Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？"></a>Servlet中如何获取用户配置的初始化参数以及服务器上下文参数？</h4><h4 id="如何设置请求的编码以及响应内容的类型？"><a href="#如何设置请求的编码以及响应内容的类型？" class="headerlink" title="如何设置请求的编码以及响应内容的类型？"></a>如何设置请求的编码以及响应内容的类型？</h4><h4 id="解释一下网络应用的模式及其特点。"><a href="#解释一下网络应用的模式及其特点。" class="headerlink" title="解释一下网络应用的模式及其特点。"></a>解释一下网络应用的模式及其特点。</h4><h4 id="什么是Web-Service（Web服务）？"><a href="#什么是Web-Service（Web服务）？" class="headerlink" title="什么是Web Service（Web服务）？"></a>什么是Web Service（Web服务）？</h4><h4 id="解释一下SOAP、WSDL、UDDI的概念。"><a href="#解释一下SOAP、WSDL、UDDI的概念。" class="headerlink" title="解释一下SOAP、WSDL、UDDI的概念。"></a>解释一下SOAP、WSDL、UDDI的概念。</h4><h4 id="Java规范中和Web-Service相关的规范有哪些？"><a href="#Java规范中和Web-Service相关的规范有哪些？" class="headerlink" title="Java规范中和Web Service相关的规范有哪些？"></a>Java规范中和Web Service相关的规范有哪些？</h4><h4 id="介绍一下你了解的Java领域的Web-Service框架。"><a href="#介绍一下你了解的Java领域的Web-Service框架。" class="headerlink" title="介绍一下你了解的Java领域的Web Service框架。"></a>介绍一下你了解的Java领域的Web Service框架。</h4><h3 id="Java-EE面试题"><a href="#Java-EE面试题" class="headerlink" title="Java EE面试题"></a>Java EE面试题</h3><blockquote>
<p>这部分主要是开源Java EE框架方面的内容，包括Hibernate、MyBatis、Spring、Spring MVC等框架。此外，这篇文章还对企业应用架构、大型网站架构和应用服务器优化等内容进行了简单的探讨。</p>
</blockquote>
<h4 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h4><h4 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</h4><h4 id="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"><a href="#Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？" class="headerlink" title="Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？"></a>Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？</h4><h4 id="Hibernate中Session的load和get方法的区别是什么？"><a href="#Hibernate中Session的load和get方法的区别是什么？" class="headerlink" title="Hibernate中Session的load和get方法的区别是什么？"></a>Hibernate中Session的load和get方法的区别是什么？</h4><h4 id="Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？"><a href="#Session的save-、update-、merge-、lock-、saveOrUpdate-和persist-方法分别是做什么的？有什么区别？" class="headerlink" title="Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？"></a>Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？</h4><h4 id="阐述Session加载实体对象的过程。"><a href="#阐述Session加载实体对象的过程。" class="headerlink" title="阐述Session加载实体对象的过程。"></a>阐述Session加载实体对象的过程。</h4><h4 id="Query接口的list方法和iterate方法有什么区别？"><a href="#Query接口的list方法和iterate方法有什么区别？" class="headerlink" title="Query接口的list方法和iterate方法有什么区别？"></a>Query接口的list方法和iterate方法有什么区别？</h4><h4 id="Hibernate如何实现分页查询？"><a href="#Hibernate如何实现分页查询？" class="headerlink" title="Hibernate如何实现分页查询？"></a>Hibernate如何实现分页查询？</h4><h4 id="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"><a href="#锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。" class="headerlink" title="锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。"></a>锁机制有什么用？简述Hibernate的悲观锁和乐观锁机制。</h4><h4 id="阐述实体对象的三种状态以及转换关系。"><a href="#阐述实体对象的三种状态以及转换关系。" class="headerlink" title="阐述实体对象的三种状态以及转换关系。"></a>阐述实体对象的三种状态以及转换关系。</h4><h4 id="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"><a href="#如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？" class="headerlink" title="如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？"></a>如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？</h4><h4 id="举一个多对多关联的例子，并说明如何实现多对多关联映射"><a href="#举一个多对多关联的例子，并说明如何实现多对多关联映射" class="headerlink" title="举一个多对多关联的例子，并说明如何实现多对多关联映射"></a>举一个多对多关联的例子，并说明如何实现多对多关联映射</h4><h4 id="谈一下你对继承映射的理解。"><a href="#谈一下你对继承映射的理解。" class="headerlink" title="谈一下你对继承映射的理解。"></a>谈一下你对继承映射的理解。</h4><h4 id="简述Hibernate常见优化策略。"><a href="#简述Hibernate常见优化策略。" class="headerlink" title="简述Hibernate常见优化策略。"></a>简述Hibernate常见优化策略。</h4><h4 id="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"><a href="#谈一谈Hibernate的一级缓存、二级缓存和查询缓存。" class="headerlink" title="谈一谈Hibernate的一级缓存、二级缓存和查询缓存。"></a>谈一谈Hibernate的一级缓存、二级缓存和查询缓存。</h4><h4 id="Hibernate中DetachedCriteria类是做什么的？"><a href="#Hibernate中DetachedCriteria类是做什么的？" class="headerlink" title="Hibernate中DetachedCriteria类是做什么的？"></a>Hibernate中DetachedCriteria类是做什么的？</h4><h4 id="OneToMany注解的mappedBy属性有什么作用？"><a href="#OneToMany注解的mappedBy属性有什么作用？" class="headerlink" title="@OneToMany注解的mappedBy属性有什么作用？"></a>@OneToMany注解的mappedBy属性有什么作用？</h4><h4 id="MyBatis中使用-和-书写占位符有什么区别？"><a href="#MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="MyBatis中使用#和$书写占位符有什么区别？"></a>MyBatis中使用#和$书写占位符有什么区别？</h4><h4 id="解释一下MyBatis中命名空间（namespace）的作用。"><a href="#解释一下MyBatis中命名空间（namespace）的作用。" class="headerlink" title="解释一下MyBatis中命名空间（namespace）的作用。"></a>解释一下MyBatis中命名空间（namespace）的作用。</h4><h4 id="MyBatis中的动态SQL是什么意思？"><a href="#MyBatis中的动态SQL是什么意思？" class="headerlink" title="MyBatis中的动态SQL是什么意思？"></a>MyBatis中的动态SQL是什么意思？</h4><h4 id="什么是IoC和DI？DI是如何实现的？"><a href="#什么是IoC和DI？DI是如何实现的？" class="headerlink" title="什么是IoC和DI？DI是如何实现的？"></a>什么是IoC和DI？DI是如何实现的？</h4><h4 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h4><h4 id="解释一下什么叫AOP（面向切面编程）？"><a href="#解释一下什么叫AOP（面向切面编程）？" class="headerlink" title="解释一下什么叫AOP（面向切面编程）？"></a>解释一下什么叫AOP（面向切面编程）？</h4><h4 id="你是如何理解”横切关注”这个概念的？"><a href="#你是如何理解”横切关注”这个概念的？" class="headerlink" title="你是如何理解”横切关注”这个概念的？"></a>你是如何理解”横切关注”这个概念的？</h4><h4 id="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h4><h4 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h4><h4 id="Spring中如何使Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？-用注解来配置Bean？有哪些相关的注解？"><a href="#Spring中如何使Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？-用注解来配置Bean？有哪些相关的注解？" class="headerlink" title="Spring中如何使Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 用注解来配置Bean？有哪些相关的注解？"></a>Spring中如何使Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 用注解来配置Bean？有哪些相关的注解？</h4><h4 id="如何在Web项目中配置Spring-MVC？"><a href="#如何在Web项目中配置Spring-MVC？" class="headerlink" title="如何在Web项目中配置Spring MVC？"></a>如何在Web项目中配置Spring MVC？</h4><h4 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h4><h4 id="如何在Spring-IoC容器中配置数据源？"><a href="#如何在Spring-IoC容器中配置数据源？" class="headerlink" title="如何在Spring IoC容器中配置数据源？"></a>如何在Spring IoC容器中配置数据源？</h4><h4 id="如何配置配置事务增强？"><a href="#如何配置配置事务增强？" class="headerlink" title="如何配置配置事务增强？"></a>如何配置配置事务增强？</h4><h4 id="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"><a href="#选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？" class="headerlink" title="选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？"></a>选择使用Spring框架的原因（Spring框架为企业级开发带来的好处有哪些）？</h4><h4 id="Spring-IoC容器配置Bean的方式？"><a href="#Spring-IoC容器配置Bean的方式？" class="headerlink" title="Spring IoC容器配置Bean的方式？"></a>Spring IoC容器配置Bean的方式？</h4><h4 id="阐述Spring框架中Bean的生命周期？"><a href="#阐述Spring框架中Bean的生命周期？" class="headerlink" title="阐述Spring框架中Bean的生命周期？"></a>阐述Spring框架中Bean的生命周期？</h4><h4 id="依赖注入时如何注入集合属性？"><a href="#依赖注入时如何注入集合属性？" class="headerlink" title="依赖注入时如何注入集合属性？"></a>依赖注入时如何注入集合属性？</h4><h4 id="Spring中的自动装配有哪些限制？"><a href="#Spring中的自动装配有哪些限制？" class="headerlink" title="Spring中的自动装配有哪些限制？"></a>Spring中的自动装配有哪些限制？</h4><h4 id="在Web项目中如何获得Spring的IoC容器？"><a href="#在Web项目中如何获得Spring的IoC容器？" class="headerlink" title="在Web项目中如何获得Spring的IoC容器？"></a>在Web项目中如何获得Spring的IoC容器？</h4><h4 id="大型网站在架构上应当考虑哪些问题？"><a href="#大型网站在架构上应当考虑哪些问题？" class="headerlink" title="大型网站在架构上应当考虑哪些问题？"></a>大型网站在架构上应当考虑哪些问题？</h4><h4 id="你用过的网站前端优化的技术有哪些？"><a href="#你用过的网站前端优化的技术有哪些？" class="headerlink" title="你用过的网站前端优化的技术有哪些？"></a>你用过的网站前端优化的技术有哪些？</h4><h4 id="你使用过的应用服务器优化技术有哪些？"><a href="#你使用过的应用服务器优化技术有哪些？" class="headerlink" title="你使用过的应用服务器优化技术有哪些？"></a>你使用过的应用服务器优化技术有哪些？</h4><h4 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击？</h4><h4 id="什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别？"><a href="#什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别？" class="headerlink" title="什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？"></a>什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</h4><h4 id="谈一谈测试驱动开发（TDD）的好处以及你的理解。"><a href="#谈一谈测试驱动开发（TDD）的好处以及你的理解。" class="headerlink" title="谈一谈测试驱动开发（TDD）的好处以及你的理解。"></a>谈一谈测试驱动开发（TDD）的好处以及你的理解。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Java面试题在google上能搜到很多，但是绝大部分博客或网站上的Java面试题都不全面。&lt;strong&gt;本博客非原创&lt;/strong&gt;，博主果冻君作为一只&lt;strong&gt;搬运工&lt;/strong&gt;，本博客&lt;strong&gt;汇总&lt;/strong&gt;了CSDN博客上&lt;a href=&quot;http://my.csdn.net/jackfrued&quot;&gt;jackfrued&lt;/a&gt;的Java面试题全集。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yaodong.ml/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://yaodong.ml/tags/Java/"/>
    
      <category term="面试题" scheme="http://yaodong.ml/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java开发岗位面试题汇总</title>
    <link href="http://yaodong.ml/Java%E5%BC%80%E5%8F%91%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB.html"/>
    <id>http://yaodong.ml/Java开发岗位面试题汇总.html</id>
    <published>2016-10-08T06:16:00.000Z</published>
    <updated>2016-10-14T11:54:20.287Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;<br>&emsp;&emsp;Java面试题在google上能搜到很多，但是绝大部分博客或网站上的Java面试题都不全面。<strong>本博客非原创</strong>，博主果冻君作为一只<strong>搬运工</strong>，本博客<strong>汇总</strong>了网上能搜到的大部分Java面试题。<br><a id="more"></a></p>
<p>&emsp;&emsp;由于是汇总，因此本博文中可能会有少量的重复试题，浏览时遇到重复试题跳过即可。</p>
<h2 id="Java面试题：part-1"><a href="#Java面试题：part-1" class="headerlink" title="Java面试题：part 1"></a>Java面试题：part 1</h2><h3 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h3><ol>
<li>String类为什么是final的。</li>
<li>HashMap的源码，实现原理，底层结构。</li>
<li>说说你知道的几个Java集合类：list、set、queue、map实现类咯。。。</li>
<li>描述一下ArrayList和LinkedList各自实现和区别</li>
<li>Java中的队列都有哪些，有什么区别。</li>
<li>反射中，Class.forName和classloader的区别</li>
<li>Java7、Java8的新特性(baidu问的,好BT)</li>
<li>Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高</li>
<li>Java内存泄露的问题调查定位：jmap，jstack的使用等等</li>
<li>string、stringbuilder、stringbuffer区别</li>
<li>hashtable和hashmap的区别</li>
<li>异常的结构，运行时异常和非运行时异常，各举个例子</li>
<li>String a= “abc” String b = “abc” String c = new String(“abc”) String d = “ab” + “c” .他们之间用 == 比较的结果</li>
<li>String 类的常用方法</li>
<li>Java 的引用类型有哪几种</li>
<li>抽象类和接口的区别</li>
<li>java的基础类型和字节大小。</li>
<li>Hashtable,HashMap,ConcurrentHashMap 底层实现原理与线程安全问题（建议熟悉 jdk 源码，才能从容应答）</li>
<li>如果不让你用Java Jdk提供的工具，你自己实现一个Map，你怎么做。说了好久，说了HashMap源代码，如果我做，就会借鉴HashMap的原理，说了一通HashMap实现</li>
<li>Hash冲突怎么办？哪些解决散列冲突的方法？</li>
<li>HashMap冲突很厉害，最差性能，你会怎么解决?从O（n）提升到log（n）咯，用二叉排序树的思路说了一通</li>
<li>rehash</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写</li>
</ol>
<h3 id="二、Java-IO"><a href="#二、Java-IO" class="headerlink" title="二、Java IO"></a>二、Java IO</h3><ol>
<li>讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞。</li>
<li>讲讲NIO。</li>
<li>String 编码UTF-8 和GBK的区别?</li>
<li>什么时候使用字节流、什么时候使用字符流?</li>
<li>递归读取文件夹下的文件，代码怎么实现</li>
</ol>
<h3 id="三、Java-Web"><a href="#三、Java-Web" class="headerlink" title="三、Java Web"></a>三、Java Web</h3><ol>
<li>session和cookie的区别和联系，session的生命周期，多个服务部署时session管理。</li>
<li>servlet的一些相关问题</li>
<li>webservice相关问题</li>
<li>jdbc连接，forname方式的步骤，怎么声明使用一个事务。举例并具体代码</li>
<li>无框架下配置web.xml的主要配置内容</li>
<li>jsp和servlet的区别</li>
</ol>
<h3 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h3><ol>
<li>Java的内存模型以及GC算法</li>
<li>jvm性能调优都做了什么</li>
<li>介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明</li>
<li>介绍GC 和GC Root不正常引用。</li>
<li>自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展</li>
<li>jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析</li>
<li>数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）</li>
<li>老年代中数组的访问方式</li>
<li>GC 算法，永久代对象如何 GC ， GC 有环怎么处理</li>
<li>谁会被 GC ，什么时候 GC</li>
<li>如果想不被 GC 怎么办</li>
<li>如果想在 GC 中生存 1 次怎么办</li>
</ol>
<h3 id="五、开源框架"><a href="#五、开源框架" class="headerlink" title="五、开源框架"></a>五、开源框架</h3><ol>
<li>hibernate和ibatis的区别</li>
<li>讲讲mybatis的连接池。</li>
<li>spring框架中需要引用哪些jar包，以及这些jar包的用途</li>
<li>springMVC的原理</li>
<li>springMVC注解的意思</li>
<li>spring中beanFactory和ApplicationContext的联系和区别</li>
<li>spring注入的几种方式（循环注入）</li>
<li>spring如何实现事物管理的</li>
<li>springIOC</li>
<li>spring AOP的原理</li>
<li>hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）</li>
<li>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。</li>
</ol>
<h3 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h3><ol>
<li>Java创建线程之后，直接调用start()方法和run()的区别</li>
<li>常用的线程池模式以及不同线程池的使用场景</li>
<li>newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。</li>
<li>多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。</li>
<li>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</li>
<li>同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高</li>
<li>atomicinteger和volatile等线程安全操作的关键字的理解和使用</li>
<li>线程间通信，wait和notify</li>
<li>定时线程的使用</li>
<li>场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。</li>
<li>进程和线程的区别</li>
<li>什么叫线程安全？举例说明</li>
<li>线程的几种状态</li>
<li>并发、同步的接口或方法</li>
<li>HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。</li>
<li>J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。</li>
<li>简单介绍下多线程的情况，从建立一个线程开始。然后怎么控制同步过程，多线程常用的方法和结构</li>
<li>volatile的理解</li>
<li>实现多线程有几种方式，多线程同步怎么做，说说几个线程里常用的方法</li>
</ol>
<h3 id="七、网络通信"><a href="#七、网络通信" class="headerlink" title="七、网络通信"></a>七、网络通信</h3><ol>
<li>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。</li>
<li>socket通信，以及长连接，分包，连接异常断开的处理。</li>
<li>socket通信模型的使用，AIO和NIO。</li>
<li>socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。</li>
<li>同步和异步，阻塞和非阻塞。</li>
<li>OSI七层模型，包括TCP,IP的一些基本知识</li>
<li>http中，get post的区别</li>
<li>说说http,tcp,udp之间关系和区别。</li>
<li>说说浏览器访问www.taobao.com，经历了怎样的过程。</li>
<li>HTTP协议、  HTTPS协议，SSL协议及完整交互过程；</li>
<li>tcp的拥塞，快回传，ip的报文丢弃</li>
<li>https处理的一个过程，对称加密和非对称加密</li>
<li>head各个特点和区别</li>
<li>说说浏览器访问www.taobao.com，经历了怎样的过程。</li>
</ol>
<h3 id="八、数据库MySql"><a href="#八、数据库MySql" class="headerlink" title="八、数据库MySql"></a>八、数据库MySql</h3><ol>
<li>MySql的存储引擎的不同</li>
<li>单个索引、联合索引、主键索引</li>
<li>Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)</li>
<li>分表之后想让一个id多个表是自增的，效率实现</li>
<li>MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离</li>
<li>写SQL语句。。。</li>
<li>索引的数据结构，B+树</li>
<li>事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题</li>
<li>数据库的锁：行锁，表锁；乐观锁，悲观锁</li>
<li>数据库事务的几种粒度；</li>
<li>关系型和非关系型数据库区别</li>
</ol>
<h3 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h3><ol>
<li>单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查</li>
<li>工厂模式、装饰者模式、观察者模式。</li>
<li>工厂方法模式的优点（低耦合、高内聚，开放封闭原则）</li>
</ol>
<h3 id="十、算法"><a href="#十、算法" class="headerlink" title="十、算法"></a>十、算法</h3><ol>
<li>使用随机算法产生一个数，要求把1-1000w之间这些数全部生成（考察高效率，解决产生冲突的问题）</li>
<li>两个有序数组的合并排序</li>
<li>一个数组的倒序</li>
<li>计算一个正整数的正平方根</li>
<li>常见的那些查找、排序算法以及各自的时间复杂度</li>
<li>二叉树的遍历算法</li>
<li>DFS、BFS算法</li>
<li>比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。</li>
<li>排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）</li>
<li>逆波兰计算器</li>
<li>Hoffman 编码</li>
<li>查找树与红黑树</li>
</ol>
<h3 id="十一、并发与性能调优"><a href="#十一、并发与性能调优" class="headerlink" title="十一、并发与性能调优"></a>十一、并发与性能调优</h3><ol>
<li>有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?</li>
<li>高并发情况下，我们系统是如何支撑大量的请求的</li>
<li>集群如何同步会话状态</li>
<li>负载均衡的原理</li>
<li>如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）</li>
<li>如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。</li>
<li>假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。</li>
<li>如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。</li>
<li>你的项目中使用过缓存机制吗？有没用用户非本地缓存</li>
</ol>
<h2 id="Java面试题：part-2"><a href="#Java面试题：part-2" class="headerlink" title="Java面试题：part 2"></a>Java面试题：part 2</h2><blockquote>
<p>本部分将讨论Java面试中的各种不同类型的面试题，它们可以测试应聘者的Java和通用的面向对象编程的能力。</p>
</blockquote>
<h3 id="一、面向对象编程（OOP）的相关问题"><a href="#一、面向对象编程（OOP）的相关问题" class="headerlink" title="一、面向对象编程（OOP）的相关问题"></a>一、面向对象编程（OOP）的相关问题</h3><h4 id="面向对象编程开发的优点"><a href="#面向对象编程开发的优点" class="headerlink" title="面向对象编程开发的优点"></a>面向对象编程开发的优点</h4><ul>
<li>代码开发模块化，更易维护和修改</li>
<li>代码复用</li>
<li>增强代码的可靠性和灵活性</li>
<li>增加代码的可理解性</li>
<li>面向对象编程有很多重要的特性：封装，继承，多态和抽象等<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4>&emsp;&emsp;封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。<br>&emsp;&emsp;下面列出了使用封装的一些好处：</li>
<li>通过隐藏对象的属性来保护对象内部的状态</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展</li>
<li>禁止对象之间的不良交互提高模块化<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4>&emsp;&emsp;多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>&emsp;&emsp;继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>&emsp;&emsp;抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<h4 id="抽象和封装的不同点"><a href="#抽象和封装的不同点" class="headerlink" title="抽象和封装的不同点"></a>抽象和封装的不同点</h4><p>&emsp;&emsp;抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p>
<h3 id="二、常见的Java细节问题"><a href="#二、常见的Java细节问题" class="headerlink" title="二、常见的Java细节问题"></a>二、常见的Java细节问题</h3><h4 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h4><p>&emsp;&emsp;Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>&emsp;&emsp;Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h4 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h4><p>&emsp;&emsp;Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<h4 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h4><p>&emsp;&emsp;“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>&emsp;&emsp;Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<h4 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h4><p>&emsp;&emsp;static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h4 id="5-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#5-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="5. Java支持的数据类型有哪些？什么是自动拆装箱？"></a>5. Java支持的数据类型有哪些？什么是自动拆装箱？</h4><p>&emsp;&emsp;Java语言支持的8种基本数据类型是：byte、short、int、long、float、double、boolean、char<br>&emsp;&emsp;自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p>
<h4 id="6-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#6-Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="6. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>6. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h4><p>&emsp;&emsp;Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h4 id="7-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#7-Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="7. Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>7. Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h4><p>&emsp;&emsp;当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。<br>&emsp;&emsp;Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>&emsp;&emsp;Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p>
<h4 id="8-Java支持多继承么？"><a href="#8-Java支持多继承么？" class="headerlink" title="8. Java支持多继承么？"></a>8. Java支持多继承么？</h4><p>&emsp;&emsp;不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p>
<h4 id="9-接口和抽象类的区别是什么？"><a href="#9-接口和抽象类的区别是什么？" class="headerlink" title="9. 接口和抽象类的区别是什么？"></a>9. 接口和抽象类的区别是什么？</h4><p>&emsp;&emsp;Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p>
<ul>
<li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类</li>
<li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口</li>
<li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量</li>
<li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。<br>也可以参考JDK8中抽象类和接口的区别</li>
</ul>
<h4 id="10-什么是值传递和引用传递？"><a href="#10-什么是值传递和引用传递？" class="headerlink" title="10. 什么是值传递和引用传递？"></a>10. 什么是值传递和引用传递？</h4><p>&emsp;&emsp;对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。<br>&emsp;&emsp;对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<h3 id="三、Java线程"><a href="#三、Java线程" class="headerlink" title="三、Java线程"></a>三、Java线程</h3><h4 id="11-进程和线程的区别是什么？"><a href="#11-进程和线程的区别是什么？" class="headerlink" title="11. 进程和线程的区别是什么？"></a>11. 进程和线程的区别是什么？</h4><p>&emsp;&emsp;进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<h4 id="12-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#12-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>12. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h4><p>&emsp;&emsp;有三种方式可以用来创建线程：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>应用程序可以使用Executor框架来创建线程池</li>
</ul>
<p>&emsp;&emsp;实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>
<h4 id="13-概括的解释下线程的几种可用状态。"><a href="#13-概括的解释下线程的几种可用状态。" class="headerlink" title="13. 概括的解释下线程的几种可用状态。"></a>13. 概括的解释下线程的几种可用状态。</h4><p>&emsp;&emsp;线程在执行过程中，可以处于下面几种状态：</p>
<ul>
<li>就绪(Runnable):线程准备运行，不一定立马就能开始执行</li>
<li>运行(Running)：进程正在执行线程的代码</li>
<li>等待(Waiting):线程处于阻塞的状态，等待外部的处理结束</li>
<li>睡眠(Sleeping)：线程被强制睡眠</li>
<li>I/O阻塞(Blocked on I/O)：等待I/O操作完成</li>
<li>同步阻塞(Blocked on Synchronization)：等待获取锁</li>
<li>死亡(Dead)：线程完成了执行</li>
</ul>
<h4 id="14-同步方法和同步代码块的区别是什么？"><a href="#14-同步方法和同步代码块的区别是什么？" class="headerlink" title="14. 同步方法和同步代码块的区别是什么？"></a>14. 同步方法和同步代码块的区别是什么？</h4><p>&emsp;&emsp;在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。</p>
<h4 id="15-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#15-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="15. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>15. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h4><p>&emsp;&emsp;监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p>
<h4 id="16-什么是死锁-deadlock-？"><a href="#16-什么是死锁-deadlock-？" class="headerlink" title="16. 什么是死锁(deadlock)？"></a>16. 什么是死锁(deadlock)？</h4><p>&emsp;&emsp;两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<h4 id="17-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#17-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="17. 如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>17. 如何确保N个线程可以访问N个资源同时又不导致死锁？</h4><p>&emsp;&emsp;使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h3 id="四、Java集合类"><a href="#四、Java集合类" class="headerlink" title="四、Java集合类"></a>四、Java集合类</h3><h4 id="18-Java集合类框架的基本接口有哪些？"><a href="#18-Java集合类框架的基本接口有哪些？" class="headerlink" title="18. Java集合类框架的基本接口有哪些？"></a>18. Java集合类框架的基本接口有哪些？</h4><p>&emsp;&emsp;Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p>
<ul>
<li>Collection：代表一组对象，每一个对象都是它的子元素</li>
<li>Set：不包含重复元素的Collection</li>
<li>List：有顺序的collection，并且可以包含重复元素</li>
<li>Map：可以把键(key)映射到值(value)的对象，键不能重复</li>
</ul>
<h4 id="19-为什么集合类没有实现Cloneable和Serializable接口？"><a href="#19-为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="19. 为什么集合类没有实现Cloneable和Serializable接口？"></a>19. 为什么集合类没有实现Cloneable和Serializable接口？</h4><p>&emsp;&emsp;集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</p>
<h4 id="20-什么是迭代器-Iterator-？"><a href="#20-什么是迭代器-Iterator-？" class="headerlink" title="20. 什么是迭代器(Iterator)？"></a>20. 什么是迭代器(Iterator)？</h4><p>&emsp;&emsp;Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的<br>迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。<br>&emsp;&emsp;克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>
<h4 id="21-Iterator和ListIterator的区别是什么？"><a href="#21-Iterator和ListIterator的区别是什么？" class="headerlink" title="21. Iterator和ListIterator的区别是什么？"></a>21. Iterator和ListIterator的区别是什么？</h4><p>&emsp;&emsp;下面列出了他们的区别：</p>
<ul>
<li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List</li>
<li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向</li>
<li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等</li>
</ul>
<h4 id="22-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#22-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h4><p>&emsp;&emsp;Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h4 id="23-Java中的HashMap的工作原理是什么？"><a href="#23-Java中的HashMap的工作原理是什么？" class="headerlink" title="23. Java中的HashMap的工作原理是什么？"></a>23. Java中的HashMap的工作原理是什么？</h4><p>&emsp;&emsp;Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h4 id="24-hashCode-和equals-方法的重要性体现在什么地方？"><a href="#24-hashCode-和equals-方法的重要性体现在什么地方？" class="headerlink" title="24. hashCode()和equals()方法的重要性体现在什么地方？"></a>24. hashCode()和equals()方法的重要性体现在什么地方？</h4><p>&emsp;&emsp;Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p>
<h4 id="25-HashMap和Hashtable有什么区别？"><a href="#25-HashMap和Hashtable有什么区别？" class="headerlink" title="25. HashMap和Hashtable有什么区别？"></a>25. HashMap和Hashtable有什么区别？</h4><ul>
<li>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</li>
<li>HashMap允许键和值是null，而Hashtable不允许键或者值是null</li>
<li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境</li>
<li>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)</li>
<li>一般认为Hashtable是一个遗留的类</li>
</ul>
<h4 id="26-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#26-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="26. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>26. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h4><p>&emsp;&emsp;下面列出了Array和ArrayList的不同点</p>
<ul>
<li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型</li>
<li>Array大小是固定的，ArrayList的大小是动态变化的</li>
<li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等</li>
</ul>
<p>&emsp;&emsp;对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="27-ArrayList和LinkedList有什么区别？"><a href="#27-ArrayList和LinkedList有什么区别？" class="headerlink" title="27. ArrayList和LinkedList有什么区别？"></a>27. ArrayList和LinkedList有什么区别？</h4><p>&emsp;&emsp;ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</p>
<ul>
<li>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)</li>
<li>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引</li>
<li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素</li>
</ul>
<h4 id="28-Comparable和Comparator接口是干什么的？列出它们的区别。"><a href="#28-Comparable和Comparator接口是干什么的？列出它们的区别。" class="headerlink" title="28. Comparable和Comparator接口是干什么的？列出它们的区别。"></a>28. Comparable和Comparator接口是干什么的？列出它们的区别。</h4><p>&emsp;&emsp;Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br>&emsp;&emsp;Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
<h4 id="29-什么是Java优先级队列-Priority-Queue-？"><a href="#29-什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="29. 什么是Java优先级队列(Priority Queue)？"></a>29. 什么是Java优先级队列(Priority Queue)？</h4><p>&emsp;&emsp;PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p>
<h4 id="30-你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#30-你了解大O符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="30. 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>30. 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？</h4><p>&emsp;&emsp;大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br>大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。</p>
<h4 id="31-如何权衡是使用无序的数组还是有序的数组？"><a href="#31-如何权衡是使用无序的数组还是有序的数组？" class="headerlink" title="31. 如何权衡是使用无序的数组还是有序的数组？"></a>31. 如何权衡是使用无序的数组还是有序的数组？</h4><p>&emsp;&emsp;有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p>
<h4 id="32-Java集合类框架的最佳实践有哪些？"><a href="#32-Java集合类框架的最佳实践有哪些？" class="headerlink" title="32. Java集合类框架的最佳实践有哪些？"></a>32. Java集合类框架的最佳实践有哪些？</h4><ul>
<li>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList</li>
<li>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容</li>
<li>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException<br>使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法</li>
<li>编程的时候接口优于实现</li>
<li>底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null</li>
</ul>
<h4 id="33-Enumeration接口和Iterator接口的区别有哪些？"><a href="#33-Enumeration接口和Iterator接口的区别有哪些？" class="headerlink" title="33. Enumeration接口和Iterator接口的区别有哪些？"></a>33. Enumeration接口和Iterator接口的区别有哪些？</h4><ul>
<li>Enumeration速度是Iterator的2倍，同时占用更少的内存</li>
<li>Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象</li>
<li>Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的</li>
</ul>
<h4 id="34-HashSet和TreeSet有什么区别？"><a href="#34-HashSet和TreeSet有什么区别？" class="headerlink" title="34. HashSet和TreeSet有什么区别？"></a>34. HashSet和TreeSet有什么区别？</h4><ul>
<li>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)</li>
<li>TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)</li>
</ul>
<h3 id="五、Java垃圾回收机制"><a href="#五、Java垃圾回收机制" class="headerlink" title="五、Java垃圾回收机制"></a>五、Java垃圾回收机制</h3><h4 id="35-Java中垃圾回收有什么目的？什么时候进行垃圾回收？"><a href="#35-Java中垃圾回收有什么目的？什么时候进行垃圾回收？" class="headerlink" title="35. Java中垃圾回收有什么目的？什么时候进行垃圾回收？"></a>35. Java中垃圾回收有什么目的？什么时候进行垃圾回收？</h4><p>&emsp;&emsp;垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p>
<h4 id="36-System-gc-和Runtime-gc-会做什么事情？"><a href="#36-System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="36. System.gc()和Runtime.gc()会做什么事情？"></a>36. System.gc()和Runtime.gc()会做什么事情？</h4><p>&emsp;&emsp;这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p>
<h4 id="37-finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#37-finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="37. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>37. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h4><p>&emsp;&emsp;在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。</p>
<h4 id="38-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#38-如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="38. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>38. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h4><p>&emsp;&emsp;不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p>
<h4 id="39-Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space"><a href="#39-Java堆的结构是什么样子的？什么是堆中的永久代-Perm-Gen-space" class="headerlink" title="39. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?"></a>39. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</h4><p>&emsp;&emsp;JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。<br>&emsp;&emsp;堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p>
<h4 id="40-串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？"><a href="#40-串行-serial-收集器和吞吐量-throughput-收集器的区别是什么？" class="headerlink" title="40. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？"></a>40. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</h4><p>&emsp;&emsp;吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</p>
<h4 id="41-在Java中，对象什么时候可以被垃圾回收？"><a href="#41-在Java中，对象什么时候可以被垃圾回收？" class="headerlink" title="41. 在Java中，对象什么时候可以被垃圾回收？"></a>41. 在Java中，对象什么时候可以被垃圾回收？</h4><p>&emsp;&emsp;当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p>
<h4 id="42-JVM的永久代中会发生垃圾回收么？"><a href="#42-JVM的永久代中会发生垃圾回收么？" class="headerlink" title="42. JVM的永久代中会发生垃圾回收么？"></a>42. JVM的永久代中会发生垃圾回收么？</h4><p>&emsp;&emsp;垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h3 id="六、异常处理"><a href="#六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h3><h4 id="43-Java中的两种异常类型是什么？他们有什么区别？"><a href="#43-Java中的两种异常类型是什么？他们有什么区别？" class="headerlink" title="43. Java中的两种异常类型是什么？他们有什么区别？"></a>43. Java中的两种异常类型是什么？他们有什么区别？</h4><p>&emsp;&emsp;Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。</p>
<h4 id="44-Java中Exception和Error有什么区别？throw和throws有什么区别？"><a href="#44-Java中Exception和Error有什么区别？throw和throws有什么区别？" class="headerlink" title="44. Java中Exception和Error有什么区别？throw和throws有什么区别？"></a>44. Java中Exception和Error有什么区别？throw和throws有什么区别？</h4><p>&emsp;&emsp;Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。<br>&emsp;&emsp;throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<h4 id="45-异常处理的时候，finally代码块的重要性是什么？-译者注：作者标题的序号弄错了"><a href="#45-异常处理的时候，finally代码块的重要性是什么？-译者注：作者标题的序号弄错了" class="headerlink" title="45. 异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了)"></a>45. 异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了)</h4><p>&emsp;&emsp;无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。</p>
<h4 id="46-异常处理完成以后，Exception对象会发生什么变化？"><a href="#46-异常处理完成以后，Exception对象会发生什么变化？" class="headerlink" title="46. 异常处理完成以后，Exception对象会发生什么变化？"></a>46. 异常处理完成以后，Exception对象会发生什么变化？</h4><p>&emsp;&emsp;Exception对象会在下一个垃圾回收过程中被回收掉。</p>
<h4 id="47-finally代码块和finalize-方法有什么区别？"><a href="#47-finally代码块和finalize-方法有什么区别？" class="headerlink" title="47. finally代码块和finalize()方法有什么区别？"></a>47. finally代码块和finalize()方法有什么区别？</h4><p>&emsp;&emsp;无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。</p>
<h3 id="七、Java-Applet"><a href="#七、Java-Applet" class="headerlink" title="七、Java Applet"></a>七、Java Applet</h3><h4 id="48-什么是Applet？"><a href="#48-什么是Applet？" class="headerlink" title="48. 什么是Applet？"></a>48. 什么是Applet？</h4><p>&emsp;&emsp;java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。</p>
<h4 id="49-解释一下Applet的生命周期"><a href="#49-解释一下Applet的生命周期" class="headerlink" title="49. 解释一下Applet的生命周期"></a>49. 解释一下Applet的生命周期</h4><p>&emsp;&emsp;applet可以经历下面的状态：</p>
<ul>
<li>Init：每次被载入的时候都会被初始化</li>
<li>Start：开始执行applet</li>
<li>Stop：结束执行applet</li>
<li>Destroy：卸载applet之前，做最后的清理工作</li>
</ul>
<h4 id="50-当applet被载入的时候会发生什么？"><a href="#50-当applet被载入的时候会发生什么？" class="headerlink" title="50. 当applet被载入的时候会发生什么？"></a>50. 当applet被载入的时候会发生什么？</h4><p>&emsp;&emsp;首先，创建applet控制类的实例，然后初始化applet，最后开始运行。</p>
<h4 id="51-Applet和普通的Java应用程序有什么区别？"><a href="#51-Applet和普通的Java应用程序有什么区别？" class="headerlink" title="51. Applet和普通的Java应用程序有什么区别？"></a>51. Applet和普通的Java应用程序有什么区别？</h4><ul>
<li>applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机</li>
<li>Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行</li>
<li>Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略</li>
</ul>
<h4 id="52-Java-applet有哪些限制条件？"><a href="#52-Java-applet有哪些限制条件？" class="headerlink" title="52. Java applet有哪些限制条件？"></a>52. Java applet有哪些限制条件？</h4><p>&emsp;&emsp;主要是由于安全的原因，给applet施加了以下的限制：</p>
<ul>
<li>applet不能够载入类库或者定义本地方法</li>
<li>applet不能在宿主机上读写文件</li>
<li>applet不能读取特定的系统属性</li>
<li>applet不能发起网络连接，除非是跟宿主机</li>
<li>applet不能够开启宿主机上其他任何的程序</li>
</ul>
<h4 id="53-什么是不受信任的applet？"><a href="#53-什么是不受信任的applet？" class="headerlink" title="53. 什么是不受信任的applet？"></a>53. 什么是不受信任的applet？</h4><p>&emsp;&emsp;不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。</p>
<h4 id="54-从网络上加载的applet和从本地文件系统加载的applet有什么区别？"><a href="#54-从网络上加载的applet和从本地文件系统加载的applet有什么区别？" class="headerlink" title="54. 从网络上加载的applet和从本地文件系统加载的applet有什么区别？"></a>54. 从网络上加载的applet和从本地文件系统加载的applet有什么区别？</h4><ul>
<li>当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制</li>
<li>当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的</li>
<li>从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验</li>
</ul>
<h4 id="55-applet类加载器是什么？它会做哪些工作？"><a href="#55-applet类加载器是什么？它会做哪些工作？" class="headerlink" title="55. applet类加载器是什么？它会做哪些工作？"></a>55. applet类加载器是什么？它会做哪些工作？</h4><p>&emsp;&emsp;当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。<br>&emsp;&emsp;当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。</p>
<h4 id="56-applet安全管理器是什么？它会做哪些工作？"><a href="#56-applet安全管理器是什么？它会做哪些工作？" class="headerlink" title="56. applet安全管理器是什么？它会做哪些工作？"></a>56. applet安全管理器是什么？它会做哪些工作？</h4><p>&emsp;&emsp;applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。</p>
<h3 id="八、Swing"><a href="#八、Swing" class="headerlink" title="八、Swing"></a>八、Swing</h3><h4 id="57-弹出式选择菜单-Choice-和列表-List-有什么区别"><a href="#57-弹出式选择菜单-Choice-和列表-List-有什么区别" class="headerlink" title="57. 弹出式选择菜单(Choice)和列表(List)有什么区别"></a>57. 弹出式选择菜单(Choice)和列表(List)有什么区别</h4><p>&emsp;&emsp;Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。</p>
<h4 id="58-什么是布局管理器？"><a href="#58-什么是布局管理器？" class="headerlink" title="58. 什么是布局管理器？"></a>58. 什么是布局管理器？</h4><p>&emsp;&emsp;布局管理器用来在容器中组织组件。</p>
<h4 id="59-滚动条-Scrollbar-和滚动面板-JScrollPane-有什么区别？"><a href="#59-滚动条-Scrollbar-和滚动面板-JScrollPane-有什么区别？" class="headerlink" title="59. 滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？"></a>59. 滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？</h4><p>&emsp;&emsp;Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。</p>
<h4 id="60-哪些Swing的方法是线程安全的？"><a href="#60-哪些Swing的方法是线程安全的？" class="headerlink" title="60. 哪些Swing的方法是线程安全的？"></a>60. 哪些Swing的方法是线程安全的？</h4><p>&emsp;&emsp;只有3个线程安全的方法： repaint(), revalidate(), and invalidate()。</p>
<h4 id="61-说出三种支持重绘-painting-的组件。"><a href="#61-说出三种支持重绘-painting-的组件。" class="headerlink" title="61. 说出三种支持重绘(painting)的组件。"></a>61. 说出三种支持重绘(painting)的组件。</h4><p>&emsp;&emsp;Canvas, Frame, Panel,和Applet支持重绘。</p>
<h4 id="62-什么是裁剪-clipping-？"><a href="#62-什么是裁剪-clipping-？" class="headerlink" title="62. 什么是裁剪(clipping)？"></a>62. 什么是裁剪(clipping)？</h4><p>&emsp;&emsp;限制在一个给定的区域或者形状的绘图操作就做裁剪。</p>
<h4 id="63-MenuItem和CheckboxMenuItem的区别是什么？"><a href="#63-MenuItem和CheckboxMenuItem的区别是什么？" class="headerlink" title="63. MenuItem和CheckboxMenuItem的区别是什么？"></a>63. MenuItem和CheckboxMenuItem的区别是什么？</h4><p>&emsp;&emsp;CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。</p>
<h4 id="64-边缘布局-BorderLayout-里面的元素是如何布局的？"><a href="#64-边缘布局-BorderLayout-里面的元素是如何布局的？" class="headerlink" title="64. 边缘布局(BorderLayout)里面的元素是如何布局的？"></a>64. 边缘布局(BorderLayout)里面的元素是如何布局的？</h4><p>&emsp;&emsp;BorderLayout里面的元素是按照容器的东西南北中进行布局的。</p>
<h4 id="65-网格包布局-GridBagLayout-里面的元素是如何布局的？"><a href="#65-网格包布局-GridBagLayout-里面的元素是如何布局的？" class="headerlink" title="65. 网格包布局(GridBagLayout)里面的元素是如何布局的？"></a>65. 网格包布局(GridBagLayout)里面的元素是如何布局的？</h4><p>&emsp;&emsp;GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。</p>
<h4 id="66-Window和Frame有什么区别？"><a href="#66-Window和Frame有什么区别？" class="headerlink" title="66. Window和Frame有什么区别？"></a>66. Window和Frame有什么区别？</h4><p>&emsp;&emsp;Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。</p>
<h4 id="67-裁剪-clipping-和重绘-repainting-有什么联系？"><a href="#67-裁剪-clipping-和重绘-repainting-有什么联系？" class="headerlink" title="67. 裁剪(clipping)和重绘(repainting)有什么联系？"></a>67. 裁剪(clipping)和重绘(repainting)有什么联系？</h4><p>&emsp;&emsp;当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。</p>
<h4 id="68-事件监听器接口-event-listener-interface-和事件适配器-event-adapter-有什么关系？"><a href="#68-事件监听器接口-event-listener-interface-和事件适配器-event-adapter-有什么关系？" class="headerlink" title="68. 事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？"></a>68. 事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？</h4><p>&emsp;&emsp;事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。</p>
<h4 id="69-GUI组件如何来处理它自己的事件？"><a href="#69-GUI组件如何来处理它自己的事件？" class="headerlink" title="69. GUI组件如何来处理它自己的事件？"></a>69. GUI组件如何来处理它自己的事件？</h4><p>&emsp;&emsp;GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。</p>
<h4 id="70-Java的布局管理器比传统的窗口系统有哪些优势？"><a href="#70-Java的布局管理器比传统的窗口系统有哪些优势？" class="headerlink" title="70. Java的布局管理器比传统的窗口系统有哪些优势？"></a>70. Java的布局管理器比传统的窗口系统有哪些优势？</h4><p>&emsp;&emsp;Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。</p>
<h4 id="71-Java的Swing组件使用了哪种设计模式？"><a href="#71-Java的Swing组件使用了哪种设计模式？" class="headerlink" title="71. Java的Swing组件使用了哪种设计模式？"></a>71. Java的Swing组件使用了哪种设计模式？</h4><p>&emsp;&emsp;Java中的Swing组件使用了MVC(视图-模型-控制器)设计模式。</p>
<h3 id="九、JDBC"><a href="#九、JDBC" class="headerlink" title="九、JDBC"></a>九、JDBC</h3><h4 id="72-什么是JDBC？"><a href="#72-什么是JDBC？" class="headerlink" title="72. 什么是JDBC？"></a>72. 什么是JDBC？</h4><p>&emsp;&emsp;JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。</p>
<h4 id="73-解释下驱动-Driver-在JDBC中的角色。"><a href="#73-解释下驱动-Driver-在JDBC中的角色。" class="headerlink" title="73. 解释下驱动(Driver)在JDBC中的角色。"></a>73. 解释下驱动(Driver)在JDBC中的角色。</h4><p>&emsp;&emsp;JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。</p>
<h4 id="74-Class-forName-方法有什么作用？"><a href="#74-Class-forName-方法有什么作用？" class="headerlink" title="74. Class.forName()方法有什么作用？"></a>74. Class.forName()方法有什么作用？</h4><p>&emsp;&emsp;这个方法用来载入跟数据库建立连接的驱动。</p>
<h4 id="75-PreparedStatement比Statement有什么优势？"><a href="#75-PreparedStatement比Statement有什么优势？" class="headerlink" title="75. PreparedStatement比Statement有什么优势？"></a>75. PreparedStatement比Statement有什么优势？</h4><p>&emsp;&emsp;PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。</p>
<h4 id="76-什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？"><a href="#76-什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？" class="headerlink" title="76. 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？"></a>76. 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？</h4><p>&emsp;&emsp;CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：<code>CallableStament.prepareCall();</code></p>
<h4 id="77-数据库连接池是什么意思？"><a href="#77-数据库连接池是什么意思？" class="headerlink" title="77. 数据库连接池是什么意思？"></a>77. 数据库连接池是什么意思？</h4><p>&emsp;&emsp;像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</p>
<h3 id="十、远程方法调用（RMI）"><a href="#十、远程方法调用（RMI）" class="headerlink" title="十、远程方法调用（RMI）"></a>十、远程方法调用（RMI）</h3><h4 id="78-什么是RMI？"><a href="#78-什么是RMI？" class="headerlink" title="78. 什么是RMI？"></a>78. 什么是RMI？</h4><p>&emsp;&emsp;Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。</p>
<h4 id="79-RMI体系结构的基本原则是什么？"><a href="#79-RMI体系结构的基本原则是什么？" class="headerlink" title="79. RMI体系结构的基本原则是什么？"></a>79. RMI体系结构的基本原则是什么？</h4><p>&emsp;&emsp;RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。</p>
<h4 id="80-RMI体系结构分哪几层？"><a href="#80-RMI体系结构分哪几层？" class="headerlink" title="80. RMI体系结构分哪几层？"></a>80. RMI体系结构分哪几层？</h4><p>&emsp;&emsp;<br>RMI体系结构分以下几层：</p>
<ul>
<li>存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务</li>
<li>远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的</li>
<li>传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略</li>
</ul>
<h4 id="81-RMI中的远程接口-Remote-Interface-扮演了什么样的角色？"><a href="#81-RMI中的远程接口-Remote-Interface-扮演了什么样的角色？" class="headerlink" title="81. RMI中的远程接口(Remote Interface)扮演了什么样的角色？"></a>81. RMI中的远程接口(Remote Interface)扮演了什么样的角色？</h4><p>&emsp;&emsp;远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</p>
<h4 id="82-java-rmi-Naming类扮演了什么样的角色？"><a href="#82-java-rmi-Naming类扮演了什么样的角色？" class="headerlink" title="82. java.rmi.Naming类扮演了什么样的角色？"></a>82. java.rmi.Naming类扮演了什么样的角色？</h4><p>&emsp;&emsp;java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。</p>
<h4 id="83-RMI的绑定-Binding-是什么意思？"><a href="#83-RMI的绑定-Binding-是什么意思？" class="headerlink" title="83. RMI的绑定(Binding)是什么意思？"></a>83. RMI的绑定(Binding)是什么意思？</h4><p>&emsp;&emsp;绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。</p>
<h4 id="84-Naming类的bind-和rebind-方法有什么区别？"><a href="#84-Naming类的bind-和rebind-方法有什么区别？" class="headerlink" title="84. Naming类的bind()和rebind()方法有什么区别？"></a>84. Naming类的bind()和rebind()方法有什么区别？</h4><p>&emsp;&emsp;bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</p>
<h4 id="85-让RMI程序能正确运行有哪些步骤？"><a href="#85-让RMI程序能正确运行有哪些步骤？" class="headerlink" title="85. 让RMI程序能正确运行有哪些步骤？"></a>85. 让RMI程序能正确运行有哪些步骤？</h4><p>&emsp;&emsp;为了让RMI程序能正确运行必须要包含以下几个步骤：</p>
<ul>
<li>编译所有的源文件</li>
<li>使用rmic生成stub</li>
<li>启动rmiregistry</li>
<li>启动RMI服务器</li>
<li>运行客户端程序</li>
</ul>
<h4 id="86-RMI的stub扮演了什么样的角色？"><a href="#86-RMI的stub扮演了什么样的角色？" class="headerlink" title="86. RMI的stub扮演了什么样的角色？"></a>86. RMI的stub扮演了什么样的角色？</h4><p>&emsp;&emsp;远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：</p>
<ul>
<li>初始化到包含了远程对象的JVM的连接</li>
<li>序列化参数到远程的JVM</li>
<li>等待方法调用和执行的结果</li>
<li>反序列化返回的值或者是方法没有执行成功情况下的异常</li>
<li>把值返回给调用者</li>
</ul>
<h4 id="87-什么是分布式垃圾回收-DGC-？它是如何工作的？"><a href="#87-什么是分布式垃圾回收-DGC-？它是如何工作的？" class="headerlink" title="87. 什么是分布式垃圾回收(DGC)？它是如何工作的？"></a>87. 什么是分布式垃圾回收(DGC)？它是如何工作的？</h4><p>&emsp;&emsp;DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。</p>
<h4 id="88-RMI中使用RMI安全管理器-RMISecurityManager-的目的是什么？"><a href="#88-RMI中使用RMI安全管理器-RMISecurityManager-的目的是什么？" class="headerlink" title="88. RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？"></a>88. RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？</h4><p>&emsp;&emsp;RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。</p>
<h4 id="89-解释下Marshalling和demarshalling。"><a href="#89-解释下Marshalling和demarshalling。" class="headerlink" title="89. 解释下Marshalling和demarshalling。"></a>89. 解释下Marshalling和demarshalling。</h4><p>&emsp;&emsp;当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。</p>
<h4 id="90-解释下Serialization和Deserialization。"><a href="#90-解释下Serialization和Deserialization。" class="headerlink" title="90. 解释下Serialization和Deserialization。"></a>90. 解释下Serialization和Deserialization。</h4><p>&emsp;&emsp;Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</p>
<h3 id="十一、Servlet"><a href="#十一、Servlet" class="headerlink" title="十一、Servlet"></a>十一、Servlet</h3><h4 id="91-什么是Servlet？"><a href="#91-什么是Servlet？" class="headerlink" title="91. 什么是Servlet？"></a>91. 什么是Servlet？</h4><p>&emsp;&emsp;Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</p>
<h4 id="92-说一下Servlet的体系结构。"><a href="#92-说一下Servlet的体系结构。" class="headerlink" title="92. 说一下Servlet的体系结构。"></a>92. 说一下Servlet的体系结构。</h4><p>&emsp;&emsp;<br>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</p>
<h4 id="93-Applet和Servlet有什么区别？"><a href="#93-Applet和Servlet有什么区别？" class="headerlink" title="93. Applet和Servlet有什么区别？"></a>93. Applet和Servlet有什么区别？</h4><p>&emsp;&emsp;Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。</p>
<h4 id="94-GenericServlet和HttpServlet有什么区别？"><a href="#94-GenericServlet和HttpServlet有什么区别？" class="headerlink" title="94. GenericServlet和HttpServlet有什么区别？"></a>94. GenericServlet和HttpServlet有什么区别？</h4><p>&emsp;&emsp;GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet。这里有Servlet的例子。</p>
<h4 id="95-解释下Servlet的生命周期。"><a href="#95-解释下Servlet的生命周期。" class="headerlink" title="95. 解释下Servlet的生命周期。"></a>95. 解释下Servlet的生命周期。</h4><p>&emsp;&emsp;对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。</p>
<h4 id="96-doGet-方法和doPost-方法有什么区别？"><a href="#96-doGet-方法和doPost-方法有什么区别？" class="headerlink" title="96. doGet()方法和doPost()方法有什么区别？"></a>96. doGet()方法和doPost()方法有什么区别？</h4><ul>
<li>doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</li>
<li>doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</li>
</ul>
<h4 id="97-什么是Web应用程序？"><a href="#97-什么是Web应用程序？" class="headerlink" title="97. 什么是Web应用程序？"></a>97. 什么是Web应用程序？</h4><p>&emsp;&emsp;Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。</p>
<h4 id="98-什么是服务端包含-Server-Side-Include-？"><a href="#98-什么是服务端包含-Server-Side-Include-？" class="headerlink" title="98. 什么是服务端包含(Server Side Include)？"></a>98. 什么是服务端包含(Server Side Include)？</h4><p>&emsp;&emsp;服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。</p>
<h4 id="99-什么是Servlet链-Servlet-Chaining-？"><a href="#99-什么是Servlet链-Servlet-Chaining-？" class="headerlink" title="99. 什么是Servlet链(Servlet Chaining)？"></a>99. 什么是Servlet链(Servlet Chaining)？</h4><p>&emsp;&emsp;Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。</p>
<h4 id="100-如何知道是哪一个客户端的机器正在请求你的Servlet？"><a href="#100-如何知道是哪一个客户端的机器正在请求你的Servlet？" class="headerlink" title="100. 如何知道是哪一个客户端的机器正在请求你的Servlet？"></a>100. 如何知道是哪一个客户端的机器正在请求你的Servlet？</h4><p>&emsp;&emsp;ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。看下这里的例子。</p>
<h4 id="101-HTTP响应的结构是怎么样的？"><a href="#101-HTTP响应的结构是怎么样的？" class="headerlink" title="101. HTTP响应的结构是怎么样的？"></a>101. HTTP响应的结构是怎么样的？</h4><p>&emsp;&emsp;HTTP响应由三个部分组成：</p>
<ul>
<li>状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。</li>
<li>HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。</li>
<li>主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</li>
</ul>
<h4 id="102-什么是cookie？session和cookie有什么区别？"><a href="#102-什么是cookie？session和cookie有什么区别？" class="headerlink" title="102. 什么是cookie？session和cookie有什么区别？"></a>102. 什么是cookie？session和cookie有什么区别？</h4><p>&emsp;&emsp;cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：</p>
<ul>
<li>无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。</li>
<li>在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。</li>
</ul>
<h4 id="103-浏览器和Servlet通信使用的是什么协议？"><a href="#103-浏览器和Servlet通信使用的是什么协议？" class="headerlink" title="103. 浏览器和Servlet通信使用的是什么协议？"></a>103. 浏览器和Servlet通信使用的是什么协议？</h4><p>&emsp;&emsp;浏览器和Servlet通信使用的是HTTP协议。</p>
<h4 id="104-什么是HTTP隧道？"><a href="#104-什么是HTTP隧道？" class="headerlink" title="104. 什么是HTTP隧道？"></a>104. 什么是HTTP隧道？</h4><p>&emsp;&emsp;HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。</p>
<h4 id="105-sendRedirect-和forward-方法有什么区别？"><a href="#105-sendRedirect-和forward-方法有什么区别？" class="headerlink" title="105. sendRedirect()和forward()方法有什么区别？"></a>105. sendRedirect()和forward()方法有什么区别？</h4><p>&emsp;&emsp;sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。</p>
<h4 id="106-什么是URL编码和URL解码？"><a href="#106-什么是URL编码和URL解码？" class="headerlink" title="106. 什么是URL编码和URL解码？"></a>106. 什么是URL编码和URL解码？</h4><p>&emsp;&emsp;URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</p>
<h3 id="十二、JSP"><a href="#十二、JSP" class="headerlink" title="十二、JSP"></a>十二、JSP</h3><h4 id="107-什么是JSP页面？"><a href="#107-什么是JSP页面？" class="headerlink" title="107. 什么是JSP页面？"></a>107. 什么是JSP页面？</h4><p>&emsp;&emsp;JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。</p>
<h4 id="108-JSP请求是如何被处理的？"><a href="#108-JSP请求是如何被处理的？" class="headerlink" title="108. JSP请求是如何被处理的？"></a>108. JSP请求是如何被处理的？</h4><p>&emsp;&emsp;浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。</p>
<h4 id="109-JSP有什么优点？"><a href="#109-JSP有什么优点？" class="headerlink" title="109. JSP有什么优点？"></a>109. JSP有什么优点？</h4><p>&emsp;&emsp;下面列出了使用JSP的优点：</p>
<ul>
<li>JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码</li>
<li>JSP页面可以被预编译</li>
<li>JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来</li>
<li>开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库</li>
<li>开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面</li>
</ul>
<h4 id="110-什么是JSP指令-Directive-？JSP中有哪些不同类型的指令？"><a href="#110-什么是JSP指令-Directive-？JSP中有哪些不同类型的指令？" class="headerlink" title="110. 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？"></a>110. 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？</h4><p>&emsp;&emsp;Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在&lt;%@ 和 %&gt;之间的。下面列出了不同类型的Directive：</p>
<ul>
<li>包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面</li>
<li>页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区</li>
<li>Taglib指令： 用来声明页面中使用的自定义的标签库</li>
</ul>
<h4 id="111-什么是JSP动作-JSP-action-？"><a href="#111-什么是JSP动作-JSP-action-？" class="headerlink" title="111. 什么是JSP动作(JSP action)？"></a>111. 什么是JSP动作(JSP action)？</h4><p>&emsp;&emsp;JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：</p>
<ul>
<li>jsp:include-当JSP页面被请求的时候包含一个文件</li>
<li>jsp:useBean-找出或者是初始化Javabean</li>
<li>jsp:setProperty-设置JavaBean的属性</li>
<li>jsp:getProperty-获取JavaBean的属性</li>
<li>jsp:forward-把请求转发到新的页面</li>
<li>jsp:plugin-产生特定浏览器的代码</li>
</ul>
<h4 id="112-什么是Scriptlets？"><a href="#112-什么是Scriptlets？" class="headerlink" title="112. 什么是Scriptlets？"></a>112. 什么是Scriptlets？</h4><p>&emsp;&emsp;JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。</p>
<h4 id="113-声明-Decalaration-在哪里？"><a href="#113-声明-Decalaration-在哪里？" class="headerlink" title="113. 声明(Decalaration)在哪里？"></a>113. 声明(Decalaration)在哪里？</h4><p>&emsp;&emsp;声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。</p>
<h4 id="114-什么是表达式-Expression-？"><a href="#114-什么是表达式-Expression-？" class="headerlink" title="114. 什么是表达式(Expression)？"></a>114. 什么是表达式(Expression)？</h4><p>&emsp;&emsp;JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在&lt;%=和%&gt;这两个标签之间定义的。</p>
<h4 id="115-隐含对象是什么意思？有哪些隐含对象？"><a href="#115-隐含对象是什么意思？有哪些隐含对象？" class="headerlink" title="115. 隐含对象是什么意思？有哪些隐含对象？"></a>115. 隐含对象是什么意思？有哪些隐含对象？</h4><p>&emsp;&emsp;JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：application、page、request、response、session、exception、out、config、pageContext</p>
<h2 id="Java面试题：part-3"><a href="#Java面试题：part-3" class="headerlink" title="Java面试题：part 3"></a>Java面试题：part 3</h2><h4 id="Java的HashMap是如何工作的？"><a href="#Java的HashMap是如何工作的？" class="headerlink" title="Java的HashMap是如何工作的？"></a>Java的HashMap是如何工作的？</h4><p>&emsp;&emsp;<strong>HashMap</strong>是一个针对数据结构的键值，每个键都会有相应的值，关键是识别这样的值。HashMap 基于 hashing 原理，我们通过 put ()和 get ()方法储存和获取对象。当我们将键值对传递给 put ()方法时，它调用键对象的 hashCode ()方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals ()方法找到正确的键值对，然后返回值对象。HashMap 使用 LinkedList 来解决碰撞问题，当发生碰撞了，对象将会储存在 LinkedList 的下一个节点中。 HashMap 在每个 LinkedList 节点中储存键值对对象。</p>
<h4 id="什么是快速失败的故障安全迭代器？"><a href="#什么是快速失败的故障安全迭代器？" class="headerlink" title="什么是快速失败的故障安全迭代器？"></a>什么是快速失败的故障安全迭代器？</h4><p>&emsp;&emsp;快速失败的Java迭代器可能会引发ConcurrentModifcationException在底层集合迭代过程中被修改。故障安全作为发生在实例中的一个副本迭代是不会抛出任何异常的。快速失败的故障安全范例定义了当遭遇故障时系统是如何反应的。例如，用于失败的快速迭代器ArrayList和用于故障安全的迭代器ConcurrentHashMap。</p>
<h4 id="Java-BlockingQueue是什么？"><a href="#Java-BlockingQueue是什么？" class="headerlink" title="Java BlockingQueue是什么？"></a>Java BlockingQueue是什么？</h4><p>Java BlockingQueue是一个并发集合util包的一部分。BlockingQueue队列是一种支持操作，它等待元素变得可用时来检索，同样等待空间可用时来存储元素。</p>
<h4 id="什么时候使用ConcurrentHashMap？"><a href="#什么时候使用ConcurrentHashMap？" class="headerlink" title="什么时候使用ConcurrentHashMap？"></a>什么时候使用ConcurrentHashMap？</h4><p>&emsp;&emsp;ConcurrentHashMap被作为故障安全迭代器的一个实例，它允许完整的并发检索和更新。当有大量的并发更新时，ConcurrentHashMap此时可以被使用。这非常类似于Hashtable，但ConcurrentHashMap不锁定整个表来提供并发，所以从这点上ConcurrentHashMap的性能似乎更好一些。所以当有大量更新时ConcurrentHashMap应该被使用。</p>
<h4 id="哪一个List实现了最快插入？"><a href="#哪一个List实现了最快插入？" class="headerlink" title="哪一个List实现了最快插入？"></a>哪一个List实现了最快插入？</h4><p>&emsp;&emsp;LinkedList和ArrayList是两个不同变量列表的实现。ArrayList的优势在于动态的增长数组，非常适合初始时总长度未知的情况下使用。LinkedList的优势在于在中间位置插入和删除操作，速度是最快的。<br>&emsp;&emsp;LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>&emsp;&emsp;ArrayList实现了可变大小的数组。它允许所有元素，包括null。 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p>
<h4 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h4><ol>
<li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能。</li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。<br>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
</ol>
<h4 id="什么是CopyOnWriteArrayList，它与ArrayList有何不同？"><a href="#什么是CopyOnWriteArrayList，它与ArrayList有何不同？" class="headerlink" title="什么是CopyOnWriteArrayList，它与ArrayList有何不同？"></a>什么是CopyOnWriteArrayList，它与ArrayList有何不同？</h4><ol>
<li>CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。相比较于ArrayList它的写操作要慢一些，因为它需要实例的快照。</li>
<li>CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之间也不需要加锁，读和写之间的同步处理只是在写完后通过一个简单的”=”将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合在多线程里使用，绝对不会发生ConcurrentModificationException ，因此CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。</li>
</ol>
<h4 id="迭代器和枚举之间的区别"><a href="#迭代器和枚举之间的区别" class="headerlink" title="迭代器和枚举之间的区别"></a>迭代器和枚举之间的区别</h4><p>&emsp;&emsp;此题的意图是让你区分Iterator不同于Enumeration的两个方面：</p>
<ol>
<li>Iterator允许移除从底层集合的元素。</li>
<li>Iterator的方法名是标准化的。</li>
</ol>
<h4 id="Hashmap如何同步"><a href="#Hashmap如何同步" class="headerlink" title="Hashmap如何同步?"></a>Hashmap如何同步?</h4><p>&emsp;&emsp;当我们需要一个同步的HashMap时，有两种选择：使用Collections.synchronizedMap()来同步HashMap。<br>使用ConcurrentHashMap的这两个选项之间的首选是使用ConcurrentHashMap，这是因为我们不需要锁定整个对象，以及通过ConcurrentHashMap分区地图来获得锁。</p>
<h4 id="IdentityHashMap和HashMap的区别"><a href="#IdentityHashMap和HashMap的区别" class="headerlink" title="IdentityHashMap和HashMap的区别"></a>IdentityHashMap和HashMap的区别</h4><ol>
<li>IdentityHashMap是Map接口的实现。不同于HashMap的，这里采用参考平等。</li>
<li>在HashMap中如果两个元素是相等的，则key1.equals(key2)</li>
<li>在IdentityHashMap中如果两个元素是相等的，则key1 == key2</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.kuqin.com/shuoit/20141128/343526.html" target="_blank" rel="external">酷勤网：10个经典的Java面试题集合</a></li>
<li><a href="https://www.javacodegeeks.com/2014/04/java-interview-questions-and-answers.html" target="_blank" rel="external">JavaCodeGeeks</a></li>
<li><a href="http://www.importnew.com/10980.html" target="_blank" rel="external">115个Java面试题和答案——终极列表（上）</a></li>
<li><a href="http://www.importnew.com/11028.html" target="_blank" rel="external">115个Java面试题和答案——终极列表（下）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&lt;br&gt;&amp;emsp;&amp;emsp;Java面试题在google上能搜到很多，但是绝大部分博客或网站上的Java面试题都不全面。&lt;strong&gt;本博客非原创&lt;/strong&gt;，博主果冻君作为一只&lt;strong&gt;搬运工&lt;/strong&gt;，本博客&lt;strong&gt;汇总&lt;/strong&gt;了网上能搜到的大部分Java面试题。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yaodong.ml/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://yaodong.ml/tags/Java/"/>
    
      <category term="面试题" scheme="http://yaodong.ml/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据科学竞赛刷题网站汇总整理</title>
    <link href="http://yaodong.ml/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AB%9E%E8%B5%9B%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86.html"/>
    <id>http://yaodong.ml/数据科学竞赛刷题网站汇总整理.html</id>
    <published>2016-10-04T09:11:11.000Z</published>
    <updated>2016-10-08T06:08:07.505Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;机器学习、大数据、数据挖掘，这些词汇充斥着互联网coders的学习和工作中，时刻关注<strong>Data Science</strong>领域的前沿热点显得十分必要，特整理以下数据竞赛类网站、算法刷题OJ。<br><a id="more"></a></p>
<h3 id="数据竞赛类网站"><a href="#数据竞赛类网站" class="headerlink" title="数据竞赛类网站"></a><strong>数据竞赛类网站</strong></h3><ul>
<li><a href="https://www.kaggle.com/" target="_blank" rel="external">Kaggle</a></li>
<li><a href="https://tianchi.shuju.aliyun.com/" target="_blank" rel="external">阿里巴巴天池大数据竞赛</a></li>
<li><a href="http://www.pkbigdata.com/" target="_blank" rel="external">数据城堡</a></li>
<li><a href="http://www.wid.org.cn/data/science/player/home/" target="_blank" rel="external">CCF大数据与计算智能大赛</a></li>
<li><a href="https://www.kesci.com/apps/home_log/index.html#!/competition" target="_blank" rel="external">Kesci科赛网</a></li>
<li><a href="http://research.xiaojukeji.com/trainee.html" target="_blank" rel="external">Di-Tech算法大赛</a></li>
<li><a href="https://cloud.seu.edu.cn/contest/" target="_blank" rel="external">全国高校云计算应用创新大赛</a></li>
<li><a href="http://www.kdd.org/kdd-cup" target="_blank" rel="external">KDD-Cup</a></li>
<li><a href="http://www.kdnuggets.com/competitions/" target="_blank" rel="external">KDnuggets Competition</a></li>
<li><a href="https://www.topcoder.com/community/data-science/" target="_blank" rel="external">TopCoder大赛网</a></li>
<li><a href="http://www.saikr.com/" target="_blank" rel="external">赛氪网</a></li>
<li><a href="http://www.saikr.com/bytecup/2016" target="_blank" rel="external">Byte Cup国际机器学习竞赛</a></li>
<li><a href="http://www.wid.org.cn/data/science/player/competition/list" target="_blank" rel="external">WID数据竞赛</a></li>
<li><a href="http://www.datrain.cn/index.php/Problemlist/index" target="_blank" rel="external">数据火车竞赛网站</a></li>
<li><a href="https://www.drivendata.org/competitions/" target="_blank" rel="external">DrivenData Competition</a></li>
<li><a href="http://www.hackdata.cn/" target="_blank" rel="external">数据嗨客</a></li>
<li><a href="http://soda.datashanghai.gov.cn/" target="_blank" rel="external">上海SODA大赛</a></li>
<li><a href="http://www.tipdm.org/jszz/index.jhtml" target="_blank" rel="external">全国数据挖掘挑战赛</a></li>
<li><a href="http://www.lovedatasci.com/" target="_blank" rel="external">Challenges in Machine Learning</a></li>
</ul>
<h3 id="数据科学-amp-机器学习的在线学习资源"><a href="#数据科学-amp-机器学习的在线学习资源" class="headerlink" title="数据科学&amp;机器学习的在线学习资源"></a><strong>数据科学&amp;机器学习的在线学习资源</strong></h3><ul>
<li><a href="http://www.lovedatasci.com/" target="_blank" rel="external">数据科学家快报</a></li>
<li><a href="http://www.afenxi.com/" target="_blank" rel="external">数据分析网</a></li>
<li><a href="http://www.17bigdata.com/" target="_blank" rel="external">一起大数据</a></li>
<li><a href="http://www.36dsj.com/archives/category/ganhuo" target="_blank" rel="external">36大数据</a></li>
<li><a href="http://www.idatacamp.com/" target="_blank" rel="external">数据科学研习社</a></li>
<li><a href="http://weibo.com/fly51fly" target="_blank" rel="external">爱可可-爱生活</a></li>
<li><a href="http://weibo.com/haoawesome" target="_blank" rel="external">好东西传送门</a></li>
<li><a href="http://ml.memect.com/" target="_blank" rel="external">机器学习日报</a></li>
<li><a href="http://weibo.com/wukehao" target="_blank" rel="external">微博-数据科学家快报</a></li>
<li><a href="http://www.chalearn.org/challenges.html" target="_blank" rel="external">数据科学家快报</a></li>
<li><a href="http://dataunion.org/" target="_blank" rel="external">数盟社区</a></li>
<li><a href="http://www.wtoutiao.com/author/gh_2bb5b7eb2268.html" target="_blank" rel="external">深度学习实验室-微头条</a></li>
<li><a href="https://www.52ml.net/categories/machinelearning" target="_blank" rel="external">我爱机器学习</a></li>
<li><a href="http://deeplearning4j.org/" target="_blank" rel="external">Deep Learning for Java</a></li>
</ul>
<h3 id="算法刷题Online-Judge"><a href="#算法刷题Online-Judge" class="headerlink" title="算法刷题Online Judge"></a><strong>算法刷题Online Judge</strong></h3><ul>
<li><a href="https://leetcode.com/" target="_blank" rel="external">Leetcode</a></li>
<li><a href="https://www.nowcoder.com/" target="_blank" rel="external">牛客网</a></li>
<li><a href="http://www.lintcode.com/zh-cn/" target="_blank" rel="external">Lintcode</a></li>
<li><a href="http://www.acmcoder.com/" target="_blank" rel="external">赛码网</a></li>
<li><a href="http://acm.hdu.edu.cn/" target="_blank" rel="external">杭电OJ</a></li>
<li><a href="http://www.poj.org" target="_blank" rel="external">POJ（Peking University)</a></li>
<li><a href="http://www.lydsy.com/JudgeOnline/" target="_blank" rel="external">BZOJ大视野Judge Online</a></li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29019227&auto=1&height=66"></iframe>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;机器学习、大数据、数据挖掘，这些词汇充斥着互联网coders的学习和工作中，时刻关注&lt;strong&gt;Data Science&lt;/strong&gt;领域的前沿热点显得十分必要，特整理以下数据竞赛类网站、算法刷题OJ。&lt;br&gt;
    
    </summary>
    
      <category term="原创" scheme="http://yaodong.ml/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="算法" scheme="http://yaodong.ml/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据科学" scheme="http://yaodong.ml/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习笔记：树和二叉树</title>
    <link href="http://yaodong.ml/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>http://yaodong.ml/数据结构与算法学习笔记：树和二叉树.html</id>
    <published>2016-10-03T05:13:10.000Z</published>
    <updated>2016-11-03T05:32:04.893Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本博文总结了树和二叉树的基本概念，简单介绍了二叉树的遍历。<br><a id="more"></a></p>
<h3 id="树与二叉树的相关概念"><a href="#树与二叉树的相关概念" class="headerlink" title="树与二叉树的相关概念"></a>树与二叉树的相关概念</h3><p>&emsp;&emsp;二叉树的左右子树有严格的顺序，不可颠倒，这是二叉树与普通树的关键区别。<br>&emsp;&emsp;<strong>二叉搜索树</strong>：二叉树的一个节点的左子节点的关键字值小于这个节点，右子节点的关键字值大于（或等于）这个父节点。<br>&emsp;&emsp;<strong>平衡树与非平衡树</strong>：左子节点与左子节点对称的树为平衡树，否则就是非平衡树。<br>&emsp;&emsp;<strong>满二叉树</strong>：满二叉树除最后一层无任何子节点外，其余每一层的所有结点都有两个子结点。也就是说，除叶子结点外的所有结点均有两个子结点。满二叉树的结点数达到最大值。<strong>满二叉树的所有叶子结点必须在同一层上</strong>。<br>&emsp;&emsp;<strong>完全二叉树</strong>：完全二叉树是由满二叉树而引出来的。对于深度为<strong>K</strong>的，有<strong>N</strong>个结点的二叉树，当且仅当其编号为<strong><em>i</em></strong>的结点与深度为<strong>K</strong>的满二叉树中编号为<strong><em>i</em></strong>的结点在二叉树中的位置一一对应时称之为完全二叉树。<br>&emsp;&emsp;<strong>霍夫曼树</strong>：一种特殊结构的二叉树，每个节点要么没有子节点，要么有两个子节点。<br>&emsp;&emsp;二叉树结合了有序数组和链表的优点：在二叉树中，数据的查找效率跟在有序数组中查找一样高，同时插入、删除数据的效率和在链表中一样高。<br>&emsp;&emsp;二叉树的工作效率：时间复杂度为<strong>O(logN)</strong>。总的来说，树对所有的数据存储操作都很高效。<br>&emsp;&emsp;满二叉树的相关性质：</p>
<ul>
<li>叶子结点只能出现在深度最大的一层；</li>
<li>非叶子结点的度一定为2；</li>
<li>在同等深度的二叉树中，满二叉树的结点个数最多，叶子结点也最多；</li>
</ul>
<p>&emsp;&emsp;完全二叉树的相关性质：</p>
<ul>
<li>叶子结点只能出现在最下的两层；</li>
<li>最下层的叶子结点一定集中在左部连续位置；</li>
<li>倒数第二层如有叶子结点存在，则一定都在右部连续位置；</li>
<li>如果某结点的度为1，则该结点一定只有左孩子，不可能存在只有右孩子的情况；</li>
<li>对于同样结点数的二叉树，完全二叉树的深度最小。</li>
<li>完全二叉树除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右子树的若干结点。</li>
</ul>
<p>&emsp;&emsp;<strong>满二叉树与完全二叉树的重要区别</strong>：<strong>满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树。</strong></p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>&emsp;&emsp;1. 在二叉树的第<strong>i</strong>层最多有$2^{i}-1$个结点（$i$）；<br>&emsp;&emsp;2. 深度为<strong>k</strong>的二叉树至多有个结点；<br>&emsp;&emsp;3. 对任何一棵二叉树T，如果其终端结点数为$n<em>0$，度为<strong>2</strong>的结点数为$n_2$，则$n_0=n_2+1$；<br>&emsp;&emsp;4. 具有<strong>n</strong>个结点的完全二叉树的深度为$\lfloor log</em>{2} n \rfloor+1$<br>&emsp;&emsp;5. 如果对一棵有<strong>n</strong>个结点的完全二叉树（其深度为$\lfloor log_{2} n \rfloor+1$）的结点按层序编号，对任一结点$i$都有：</p>
<ul>
<li>如果$i=1$，则结点$i$是二叉树的根结点，无双亲；如果$i&gt;1$，则其双亲是结点$\lfloor i/2 \rfloor$;</li>
<li>如果$2i&gt;n$，则结点$i$无左孩子，结点$i$为叶子结点，否则其左孩子是结点$2i$；</li>
<li>如果$2i+1&gt;n$，则结点$i$无右孩子，否则其右孩子是结点$2i+1$。</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>&emsp;&emsp;二叉树常用的存储结构是：<strong>孩子兄弟表示法</strong>和<strong>二叉链表</strong>。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="前序遍历：根-左-右"><a href="#前序遍历：根-左-右" class="headerlink" title="前序遍历：根 左 右"></a><strong>前序遍历</strong>：根 左 右</h4><ol>
<li>递归遍历（较简单）</li>
<li>非递归遍历（借助<strong>Stack</strong>结构实现）：</li>
</ol>
<ul>
<li>当访问到任一结点<strong>p</strong>：输出结点<strong>p</strong>，并将该结点入栈；</li>
<li>判断结点<strong>p</strong>的左孩子是否为空：<ol>
<li>若不为空，并将<strong>p</strong>的左孩子置为当前结点，回到1，循环；</li>
<li>若为空，则对栈顶结点进行出栈操作，但不输出，并将待出栈结点的右孩子置为当前结点，判断是否为空：<pre><code> 1. 若不为空，回到1，循环操作；
 2. 若为空，则对栈顶结点进行出栈操作，但不输出，即重复上述操作
</code></pre></li>
</ol>
</li>
<li>直到栈为空且当前结点为空，则遍历结束<h4 id="中序遍历：左-根-右"><a href="#中序遍历：左-根-右" class="headerlink" title="中序遍历：左 根 右"></a><strong>中序遍历</strong>：左 根 右</h4></li>
<li>递归遍历（较简单）</li>
<li>非递归遍历（借助<strong>Stack</strong>结构实现）：</li>
</ul>
<ol>
<li>对任一结点<strong>p</strong>，若<strong>p</strong>的左孩子结点不为空，则将<strong>p</strong>入栈并将<strong>p</strong>的左孩子结点置为当前结点，一直对当前结点做相同处理；</li>
<li>若当前结点<strong>p</strong>左孩子为空，则输出结点<strong>p</strong>，然后将<strong>p</strong>的右孩子置为当前结点，并判断其是否为空：<ul>
<li>(1)：若不为空，重复1,2操作</li>
<li>(2)：若为空，则执行出栈操作，输出栈顶结点，并将栈顶结点的右孩子结点置为当前结点，并判断是否为空；重复(1), (2)操作；</li>
</ul>
</li>
<li>直至当前结点<strong>p</strong>为<code>NULL</code>且栈为空，遍历结束；<h4 id="后序遍历：左-右-根"><a href="#后序遍历：左-右-根" class="headerlink" title="后序遍历：左 右 根"></a><strong>后序遍历</strong>：左 右 根</h4></li>
</ol>
<ul>
<li>递归遍历（较简单）</li>
<li>非递归遍历（借助<strong>Stack</strong>结构实现）,后序遍历的非递归的实现相对来说要难一些，因为<strong>后序遍历要保证根节点在左子树和右子树被访问后才能访问</strong>，思路如下：<ul>
<li><strong>思路1</strong>：核心思想是将暂时不访问的右、左孩子结点依次入栈</li>
</ul>
</li>
</ul>
<ol>
<li>对于任意结点<strong>p</strong>，先将<strong>p</strong>入栈；</li>
<li>若P不存在左孩子和右孩子，或者P存在左孩子或右孩子，但左右孩子已经被输出，则可以直接输出结点P，并将其出栈，将出栈结点P标记为上一个输出的结点，再将此时的栈顶结点设为当前结点；</li>
<li>若不满足2中的条件，则将<strong>p</strong>的右孩子和左孩子依次入栈（先右后左），当前节点重新置为栈顶结点，重复步骤2；</li>
<li>直至栈空，遍历结束。<ul>
<li><strong>思路2</strong>：<ol>
<li>对于任一结点<strong>current</strong>，当结点<strong>current</strong>非空时，将其右孩子结点入栈，然后<strong>current</strong>入栈，设置<strong>current</strong>的左孩子为<strong>current</strong>然后沿左子树一直深度搜索，一直down到最左孩子结点，</li>
<li>设置栈顶元素为<strong>current</strong>，并将其出栈，判断该出栈结点的右孩子是否为空：<ul>
<li>若<strong>current</strong>的右孩子不为空，栈不为空且右孩子是栈顶结点，则再将栈顶结点出栈（<strong>current</strong>的右孩子结点）， 设置<code>current=current.right</code></li>
<li>如果出栈结点的右孩子为空，则可以访问该结点，并且设置<strong>current=null</strong></li>
</ul>
</li>
<li>重复步骤2直至栈为空(null)，遍历结束。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="层序遍历：从上到下，从左到右"><a href="#层序遍历：从上到下，从左到右" class="headerlink" title="层序遍历：从上到下，从左到右"></a><strong>层序遍历</strong>：从上到下，从左到右</h4><ul>
<li>递归结构</li>
<li>层序遍历的非递归结构可借助队列Queue来实现：</li>
</ul>
<ol>
<li>将根结点入队；</li>
<li>如果队列不空，则进入以下循环：<ul>
<li>将队首的结点出队，并输出该结点；</li>
<li>如果该结点有左孩子，则将其左孩子入队；</li>
<li>如果该结点有右孩子吗，则将其右孩子入队。</li>
</ul>
</li>
</ol>
<hr>
<p>&emsp;&emsp;霍夫曼树以及其他二叉树的知识后续会在博文下次更新时整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本博文总结了树和二叉树的基本概念，简单介绍了二叉树的遍历。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yaodong.ml/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习笔记" scheme="http://yaodong.ml/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="树" scheme="http://yaodong.ml/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://yaodong.ml/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning学习笔记：决策树与随机森林</title>
    <link href="http://yaodong.ml/Machine-Learning%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.html"/>
    <id>http://yaodong.ml/Machine-Learning学习笔记：决策树与随机森林.html</id>
    <published>2016-10-03T04:54:14.000Z</published>
    <updated>2016-11-03T05:08:56.741Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="决策树-Decision-Tree"><a href="#决策树-Decision-Tree" class="headerlink" title="决策树(Decision Tree)"></a>决策树(Decision Tree)</h2><p>&emsp;&emsp;决策树是一种基本的分类与回归算法，属于<strong>贪婪算法</strong>，其模型呈现为树形结构，可理解为基于特征或模型属性对实例进行分类或回归的过程<br>&emsp;&emsp;决策树的特点：</p>
<ul>
<li><strong>优点</strong>：计算复杂度不高，输出结果可直观理解数据，对中间值得缺失不敏感，可以处理不相关特征数据</li>
<li><strong>缺点</strong>：可能会出现Over Fittting</li>
<li>适用数据类型：数值型和标称型</li>
</ul>
<p>&emsp;&emsp;决策树的路径及其对应的<code>if-then</code>重要性质：路径之间是互斥且完备的。也就是说，每一个实例都被决策树的一条路径覆盖，且只能被一条路径或者一条规则覆盖。这里的覆盖是指实例的特征与路径上的特征或实例满足规则的条件</p>
<h3 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h3><p>&emsp;&emsp;决策树模型学习过程可分为3个步骤：<strong>特征选择</strong>，<strong>决策树的生成</strong>，<strong>决策树的修剪</strong></p>
<h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>&emsp;&emsp;构建决策树，实质是对训练数据集进行超平面划分，不同的样本特征在划分数据集时重要性不同，因此选择特征顺序的不同将会生成不同的决策树。为使数据集的分类结果更纯净，更能直观表达数据的本质属性，构造决策树之前先评估不同特征的重要性。</p>
<h3 id="决策树生成算法"><a href="#决策树生成算法" class="headerlink" title="决策树生成算法"></a>决策树生成算法</h3><p>&emsp;&emsp;<strong>ID3</strong>与<strong>C4.5</strong>都是决策树的经典分类决策树算法。<strong>ID3</strong>算法与<strong>C4.5</strong>算法的不同之处在于ID3算法采用信息增益作为特征选择准则，而C4.5采用的是信息增益比作为准则</p>
<h4 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h4><p>&emsp;&emsp;<strong>ID3</strong>算法的核心是在决策树的各个节点上应用信息增益准则选择特征，递归地构建决策树。<br>&emsp;&emsp;<strong>ID3</strong>算法的实质是用最大似然法进行概率模型的选择。算法思路为：</p>
<ul>
<li>从根节点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子节点</li>
<li>再对子结点递归调用以上方法，构建决策树。直到所有特征的信息增益均很小或没有特征可以选择为止。</li>
</ul>
<h4 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h4><p>&emsp;&emsp;<strong>ID3</strong>算法由于只有树的生成，所以该算法生成的树容易产生过拟合。<strong>C4.5</strong>算法对<strong>ID3</strong>算法进行了改进，选用信息增益比作为特征选择准则。</p>
<h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>&emsp;&emsp;用决策树生成算法递归产生决策树，容易出现过拟合，原因在于决策树的生成过程过多考虑如何提高对训练数据的正确分类，从而构建的决策树趋于复杂<br>&emsp;&emsp;在决策树学习中，将已生成的树进行简化的过程称为剪枝，具体来说就是剪掉一些子树或叶子结点，并将其根节点或父结点作为新的叶子结点，进而简化决策树模型<br>&emsp;&emsp;决策树的剪枝通过极小化决策树整体的损失函数（代价函数）来实现，即<script type="math/tex">C_\alpha(T)=C(T)+\alpha|T|</script></p>
<h4 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h4><p>&emsp;&emsp;<strong>CART</strong>算法是一种既可以用于分类也可用作回归的决策树算法。<strong>CART</strong>算法分为以下两步：</p>
<ol>
<li>决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大</li>
<li>决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，此过程中，用损失函数最小化作为剪枝的标准</li>
</ol>
<hr>
<h2 id="随机森林算法"><a href="#随机森林算法" class="headerlink" title="随机森林算法"></a>随机森林算法</h2><h3 id="Bagging方法"><a href="#Bagging方法" class="headerlink" title="Bagging方法"></a>Bagging方法</h3><p>&emsp;&emsp;Bagging方法就是将所有training data放进一个“黑色”的bag中，然后从这个bag中随机抽取部分数据生成新的训练集。随机森林算法中，样本训练集本省可以使用bagging方法，同样，样本的feature也可以进行bagging。从随机性来看，bagging技术可以有效的减小方差，即减小过拟合程度<br>&emsp;&emsp;随机森林是一种经典而强大的机器学习算法，具有回归和分类的功能。随机森林算法由若干决策树组成，这些决策树一般采用随机的方法生成，因此也叫做随机决策树。随机森林算法中的各决策树之间是没有关联的。</p>
<p>&emsp;&emsp;随机森林算法的<strong>特点</strong>：</p>
<ul>
<li>适合用于多分类问题，算法训练和预测速度快，容易实现并行化</li>
<li>可有效估计缺失数据，即有一定程度的数据容错能力，当数据集中有大比例的数据缺失时仍然可以保持精度不变和能够有效地处理大的数据集</li>
<li>不会出现过拟合</li>
<li>能够处理很高维度（feature很多）的数据，并且不用做特征选择</li>
<li>对数据集的适应能力强：既能处理离散型数据，也能处理连续型数据，数据集无需规范化</li>
<li>可检测样本的各特征（维度）之间的相互影响程度，判断特征对所解决问题的重要性程度</li>
<li>可直接处理大规模的的变量（群）</li>
<li>在创建森林即分类的过程中，对泛化误差的估计是内部无偏估计</li>
<li>随机森林算法也是一种数据降维的方法，用于处理缺失值、异常值</li>
</ul>
<h3 id="Bootstrap抽样"><a href="#Bootstrap抽样" class="headerlink" title="Bootstrap抽样"></a>Bootstrap抽样</h3><p>&emsp;&emsp;随机森林算法中包含了对输入数据的重复自抽样过程，即所谓的bootstrap抽样。大约三分之一的数据集将用于测试而不是模型的训练，这样的数据被称为out of bag samples。</p>
<p>&emsp;&emsp;bootstrap抽样与bagging的区别是：在生成每棵树的时候，每个节点变量都仅仅在随机选出的少数变量中产生。因此，不但样本是随机的，连每个节点变量（Features）的产生都是随机的。<br>&emsp;&emsp;综上可知，随机森林算法的的两个随机采样的过程保证了随机性，所以即使对最终的各决策树不剪枝，也不会出现over-fitting。</p>
<h3 id="随机森林算法的具体步骤："><a href="#随机森林算法的具体步骤：" class="headerlink" title="随机森林算法的具体步骤："></a>随机森林算法的具体步骤：</h3><ol>
<li>通过自助法（bootstrap）重采样技术，从原始训练样本集中有放回地重复随机抽取N个样本生成新的训练样本集合</li>
<li>对随机采样得到的新训练数据集，构建决策树，在每个节点执行以下操作：</li>
</ol>
<ul>
<li>从样本数据的M个features中随机选取m($m&lt;&lt;M$)个feature</li>
<li>对这m个features，选择特定的度量准则分割节点</li>
<li>重复上述操作N次，从而生成与样本数量相等的决策树</li>
</ul>
<ol>
<li>对于每一个测试样例，对k颗决策树的预测结果进行投票。票数最多的结果就是随机森林的分裂（预测）结果</li>
</ol>
<h3 id="scikit-learn中的Random-Forest算法"><a href="#scikit-learn中的Random-Forest算法" class="headerlink" title="scikit-learn中的Random Forest算法"></a>scikit-learn中的Random Forest算法</h3><p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sklearn.ensemble.RandomForestClassfier</div><div class="line">clf = RandomForestClassifier([parameters]) <span class="comment">#generator the entity object of classifier</span></div><div class="line">parameters:</div><div class="line">n_estimators：指定随机森林中树的数目，越多越好，不超过内存即可</div><div class="line">criterion:指定在分裂使用的决策算法，取值有“entropy”、“gini”等</div><div class="line">max_features:单个决策树使用特征的最大数量，取值为<span class="string">"Auto"</span>，<span class="string">"None"</span>，<span class="string">"sqrt"</span>，<span class="string">"0.X"</span>。回归问题，max_features=n_features,分类问题，max_features=sqrt(n_features),<span class="string">"sqrt"</span>即为全部特征数目的平均根</div><div class="line">max_depth:默认为<span class="keyword">None</span>，一般可不改动</div><div class="line">min_simples_split:</div><div class="line">min_samples_leaf:最小叶片大小。默认值为<span class="number">1</span>，可设置为<span class="number">50</span>。叶是决策树的末端节点，较小的叶子使模型更容易捕捉训练数据中的噪声。</div><div class="line">min_weight_fraction_leaf:</div><div class="line">max_leaf_nodes:</div><div class="line">min_impurity_split:</div><div class="line">bootstrap:</div><div class="line">oob_score:这是一个随机森林交叉验证方法，取值为boolean类型，<span class="string">"True"</span>,<span class="string">"False"</span></div><div class="line">n_jobs:指定并行训练时使用的进程数。“<span class="number">-1</span>”表示使用所有处理器</div><div class="line">random_state:经验值<span class="string">"random_state=50"</span></div><div class="line">verbose:</div><div class="line">warm_state:</div><div class="line">class_weight:</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;决策树-Decision-Tree&quot;&gt;&lt;a href=&quot;#决策树-Decision-Tree&quot; class=&quot;headerlink&quot; title=&quot;决策树(Decision Tree)&quot;&gt;&lt;/a&gt;决策树(Decision Tre
    
    </summary>
    
      <category term="机器学习" scheme="http://yaodong.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://yaodong.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Machine-Learning/"/>
    
      <category term="学习笔记" scheme="http://yaodong.ml/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Machine-Learning/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://yaodong.ml/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://yaodong.ml/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
